[
    {
        "url": "https://dev.classmethod.jp/articles/amazon-q-developer-agent-capabilities-include-generating-documentation/",
        "status": "success",
        "content": "  AWS re:Invent 2024#Amazon Q#AWS AWS re:Invent 2024 AWS re:Invent 2024 AWS re:Invent 2024 AWS re:Invent 2024 #Amazon Q#AWS #Amazon Q #Amazon Q #AWS #AWS 中川翔太2024.12.04 中川翔太 中川翔太  中川翔太   2024.12.04 2024.12.04 2024.12.04 中川です。\nAmazon Q Developer エージェントの新機能としてドキュメント生成が発表されました。\nhttps://aws.amazon.com/jp/about-aws/whats-new/2024/12/amazon-q-developer-generate-documentation-source-code/\nhttps://aws.amazon.com/jp/blogs/aws/new-amazon-q-developer-agent-capabilities-include-generating-documentation-code-reviews-and-unit-tests/\nプロジェクトのコードを元に Readme ファイルとデータフロー図を自動生成してくれます。\nこの新しい機能により、Q Developer は既存のコードベースをより速く理解したり、新しい機能を素早く文書化したりすることができます。\n やってみた\n早速やってみました。\nドキュメントを参考に CDK のサンプルアプリケーションを作成します。\nVSCode で作成したプロジェクトを開き、Amazon Q の拡張機能を表示します。\nチャット欄に /doc と入力してエンターを入れます。\n\nREADME を作成するか更新するか提案されるので、今回はそのまま「Create a README」を選択します。\n\nプロジェクトを聞かれるので、そのまま「Yes」を選択します。\n\nソースファイルのスキャン、ソースファイルの要約がされた後に、ドキュメントの生成が行われています。\n\nドキュメントの生成が完了すると生成されたファイルと、それを受け入れるか, 拒否するか, 再生成するか、表示されます。\n見た感じ良さそうだったので、[Accept]をクリックします。\n\nファイルが保存され、プレビュー結果が自動で表示されました。\n\nブロックや見出しの使い方が上手で、データフロー図も綺麗に作成してくれることを確認できました。\n\n生成された README の全文は以下より参照ください。\nREADME 全文 AWS CDK Hello World Lambda Function\nThis project demonstrates how to create a simple \"Hello World\" Lambda function using AWS CDK with TypeScript.\nThe AWS Cloud Development Kit (CDK) is an open-source software development framework to define cloud infrastructure in code and provision it through AWS CloudFormation. This project sets up a basic CDK application that deploys a Lambda function with a function URL, allowing you to invoke the function via HTTP requests.\nThe Lambda function returns a simple \"Hello World\" message when invoked. This project serves as a starting point for more complex serverless applications and showcases the power of infrastructure as code using AWS CDK.\n Repository Structure\n.\n├── bin\n│   └── hello-cdk.ts\n├── lib\n│   └── hello-cdk-stack.ts\n├── test\n│   └── hello-cdk.test.ts\n├── cdk.json\n├── jest.config.js\n├── package.json\n└── tsconfig.json\n\nbin/hello-cdk.ts: Entry point for the CDK application\nlib/hello-cdk-stack.ts: Defines the main CDK stack with the Lambda function\ntest/hello-cdk.test.ts: Contains tests for the CDK stack (currently commented out)\ncdk.json: CDK configuration file\njest.config.js: Jest testing framework configuration\npackage.json: Node.js project configuration and dependencies\ntsconfig.json: TypeScript compiler configuration\n\n Usage Instructions\n Prerequisites\n\nNode.js (v14.x or later)\nAWS CLI configured with appropriate credentials\nAWS CDK CLI (v2.x)\n\n Installation\n\n\nClone the repository:\ngit clone <repository-url>\ncd hello-cdk\n\n\nInstall dependencies:\nnpm install\n\n\n Deploying the Stack\n\n\nSynthesize the CloudFormation template:\nnpx cdk synth\n\n\nDeploy the stack:\nnpx cdk deploy\n\n\nAfter deployment, the CDK will output the function URL. You can use this URL to invoke your Lambda function.\n Testing\nTo run the tests (once implemented):\nnpm test\n Modifying the Lambda Function\nThe Lambda function is defined inline in lib/hello-cdk-stack.ts. To modify its behavior, update the code within the lambda.Code.fromInline() method.\n Troubleshooting\n\n\nIssue: CDK deployment fails\n\nEnsure your AWS CLI is correctly configured with the appropriate permissions\nCheck the CloudFormation console for detailed error messages\nVerify that you have the latest version of the CDK CLI installed\n\n\n\nIssue: Lambda function returns an error\n\nCheck the CloudWatch logs for the Lambda function\nEnsure the function handler matches the one specified in the CDK stack\n\n\n\nIssue: Unable to invoke the Lambda function URL\n\nVerify that the function URL is correctly output after deployment\nEnsure your network allows outbound HTTPS connections\n\n\n\nFor more detailed debugging:\n\nEnable CDK debug logging:export CDK_DEBUG=true\n\nUse the --debug flag with CDK commands for verbose output\n\n Data Flow\n\nUser sends an HTTP request to the Lambda function URL\nAPI Gateway (managed by Lambda function URLs) receives the request and forwards it to the Lambda function\nLambda function executes, generating a \"Hello World\" response\nThe response is sent back through API Gateway to the user\n\n[User]->[Function URL]->[Lambda]->[Function URL]->[User]\nNote: The Lambda function in this project is simple and stateless. For more complex applications, you might introduce additional components like databases or other AWS services.\n Infrastructure\nThis project uses AWS CDK to define the following resources:\n Lambda\n\nHelloWorldFunction: A Node.js Lambda function that returns a \"Hello World\" message\n\nRuntime: Node.js 20.x\nHandler: index.handler\nCode: Defined inline in the CDK stack\n\n\n\n Lambda Function URL\n\nFunction URL: Provides HTTP(S) endpoint for the Lambda function\n\nAuth Type: NONE (public access)\n\n\n\n CloudFormation Outputs\n\nmyFunctionUrlOutput: The URL of the Lambda function, allowing easy access to the function's endpoint\n\nThe infrastructure is defined in the HelloCdkStack class within lib/hello-cdk-stack.ts.\n\n さいごに\nAmazon Q Developer エージェントの新機能としてドキュメント生成が発表されたので試してみました。\n予想以上にきれいなドキュメントが生成されてびっくりしています。\nますます Amazon Q が日本語対応してくれるときが楽しみになりました！\n 中川です。\nAmazon Q Developer エージェントの新機能としてドキュメント生成が発表されました。\nhttps://aws.amazon.com/jp/about-aws/whats-new/2024/12/amazon-q-developer-generate-documentation-source-code/\nhttps://aws.amazon.com/jp/blogs/aws/new-amazon-q-developer-agent-capabilities-include-generating-documentation-code-reviews-and-unit-tests/\nプロジェクトのコードを元に Readme ファイルとデータフロー図を自動生成してくれます。\nこの新しい機能により、Q Developer は既存のコードベースをより速く理解したり、新しい機能を素早く文書化したりすることができます。\n やってみた\n早速やってみました。\nドキュメントを参考に CDK のサンプルアプリケーションを作成します。\nVSCode で作成したプロジェクトを開き、Amazon Q の拡張機能を表示します。\nチャット欄に /doc と入力してエンターを入れます。\n\nREADME を作成するか更新するか提案されるので、今回はそのまま「Create a README」を選択します。\n\nプロジェクトを聞かれるので、そのまま「Yes」を選択します。\n\nソースファイルのスキャン、ソースファイルの要約がされた後に、ドキュメントの生成が行われています。\n\nドキュメントの生成が完了すると生成されたファイルと、それを受け入れるか, 拒否するか, 再生成するか、表示されます。\n見た感じ良さそうだったので、[Accept]をクリックします。\n\nファイルが保存され、プレビュー結果が自動で表示されました。\n\nブロックや見出しの使い方が上手で、データフロー図も綺麗に作成してくれることを確認できました。\n\n生成された README の全文は以下より参照ください。\nREADME 全文 AWS CDK Hello World Lambda Function\nThis project demonstrates how to create a simple \"Hello World\" Lambda function using AWS CDK with TypeScript.\nThe AWS Cloud Development Kit (CDK) is an open-source software development framework to define cloud infrastructure in code and provision it through AWS CloudFormation. This project sets up a basic CDK application that deploys a Lambda function with a function URL, allowing you to invoke the function via HTTP requests.\nThe Lambda function returns a simple \"Hello World\" message when invoked. This project serves as a starting point for more complex serverless applications and showcases the power of infrastructure as code using AWS CDK.\n Repository Structure\n.\n├── bin\n│   └── hello-cdk.ts\n├── lib\n│   └── hello-cdk-stack.ts\n├── test\n│   └── hello-cdk.test.ts\n├── cdk.json\n├── jest.config.js\n├── package.json\n└── tsconfig.json\n\nbin/hello-cdk.ts: Entry point for the CDK application\nlib/hello-cdk-stack.ts: Defines the main CDK stack with the Lambda function\ntest/hello-cdk.test.ts: Contains tests for the CDK stack (currently commented out)\ncdk.json: CDK configuration file\njest.config.js: Jest testing framework configuration\npackage.json: Node.js project configuration and dependencies\ntsconfig.json: TypeScript compiler configuration\n\n Usage Instructions\n Prerequisites\n\nNode.js (v14.x or later)\nAWS CLI configured with appropriate credentials\nAWS CDK CLI (v2.x)\n\n Installation\n\n\nClone the repository:\ngit clone <repository-url>\ncd hello-cdk\n\n\nInstall dependencies:\nnpm install\n\n\n Deploying the Stack\n\n\nSynthesize the CloudFormation template:\nnpx cdk synth\n\n\nDeploy the stack:\nnpx cdk deploy\n\n\nAfter deployment, the CDK will output the function URL. You can use this URL to invoke your Lambda function.\n Testing\nTo run the tests (once implemented):\nnpm test\n Modifying the Lambda Function\nThe Lambda function is defined inline in lib/hello-cdk-stack.ts. To modify its behavior, update the code within the lambda.Code.fromInline() method.\n Troubleshooting\n\n\nIssue: CDK deployment fails\n\nEnsure your AWS CLI is correctly configured with the appropriate permissions\nCheck the CloudFormation console for detailed error messages\nVerify that you have the latest version of the CDK CLI installed\n\n\n\nIssue: Lambda function returns an error\n\nCheck the CloudWatch logs for the Lambda function\nEnsure the function handler matches the one specified in the CDK stack\n\n\n\nIssue: Unable to invoke the Lambda function URL\n\nVerify that the function URL is correctly output after deployment\nEnsure your network allows outbound HTTPS connections\n\n\n\nFor more detailed debugging:\n\nEnable CDK debug logging:export CDK_DEBUG=true\n\nUse the --debug flag with CDK commands for verbose output\n\n Data Flow\n\nUser sends an HTTP request to the Lambda function URL\nAPI Gateway (managed by Lambda function URLs) receives the request and forwards it to the Lambda function\nLambda function executes, generating a \"Hello World\" response\nThe response is sent back through API Gateway to the user\n\n[User]->[Function URL]->[Lambda]->[Function URL]->[User]\nNote: The Lambda function in this project is simple and stateless. For more complex applications, you might introduce additional components like databases or other AWS services.\n Infrastructure\nThis project uses AWS CDK to define the following resources:\n Lambda\n\nHelloWorldFunction: A Node.js Lambda function that returns a \"Hello World\" message\n\nRuntime: Node.js 20.x\nHandler: index.handler\nCode: Defined inline in the CDK stack\n\n\n\n Lambda Function URL\n\nFunction URL: Provides HTTP(S) endpoint for the Lambda function\n\nAuth Type: NONE (public access)\n\n\n\n CloudFormation Outputs\n\nmyFunctionUrlOutput: The URL of the Lambda function, allowing easy access to the function's endpoint\n\nThe infrastructure is defined in the HelloCdkStack class within lib/hello-cdk-stack.ts.\n\n さいごに\nAmazon Q Developer エージェントの新機能としてドキュメント生成が発表されたので試してみました。\n予想以上にきれいなドキュメントが生成されてびっくりしています。\nますます Amazon Q が日本語対応してくれるときが楽しみになりました！\n 中川です。 Amazon Q Developer エージェントの新機能としてドキュメント生成が発表されました。 https://aws.amazon.com/jp/about-aws/whats-new/2024/12/amazon-q-developer-generate-documentation-source-code/  https://aws.amazon.com/jp/blogs/aws/new-amazon-q-developer-agent-capabilities-include-generating-documentation-code-reviews-and-unit-tests/  プロジェクトのコードを元に Readme ファイルとデータフロー図を自動生成してくれます。\nこの新しい機能により、Q Developer は既存のコードベースをより速く理解したり、新しい機能を素早く文書化したりすることができます。 早速やってみました。\nドキュメントを参考に CDK のサンプルアプリケーションを作成します。 VSCode で作成したプロジェクトを開き、Amazon Q の拡張機能を表示します。\nチャット欄に /doc と入力してエンターを入れます。  README を作成するか更新するか提案されるので、今回はそのまま「Create a README」を選択します。  プロジェクトを聞かれるので、そのまま「Yes」を選択します。  ソースファイルのスキャン、ソースファイルの要約がされた後に、ドキュメントの生成が行われています。  ドキュメントの生成が完了すると生成されたファイルと、それを受け入れるか, 拒否するか, 再生成するか、表示されます。\n見た感じ良さそうだったので、[Accept]をクリックします。  ファイルが保存され、プレビュー結果が自動で表示されました。  ブロックや見出しの使い方が上手で、データフロー図も綺麗に作成してくれることを確認できました。  生成された README の全文は以下より参照ください。  AWS CDK Hello World Lambda Function\nThis project demonstrates how to create a simple \"Hello World\" Lambda function using AWS CDK with TypeScript.\nThe AWS Cloud Development Kit (CDK) is an open-source software development framework to define cloud infrastructure in code and provision it through AWS CloudFormation. This project sets up a basic CDK application that deploys a Lambda function with a function URL, allowing you to invoke the function via HTTP requests.\nThe Lambda function returns a simple \"Hello World\" message when invoked. This project serves as a starting point for more complex serverless applications and showcases the power of infrastructure as code using AWS CDK.\n Repository Structure\n.\n├── bin\n│   └── hello-cdk.ts\n├── lib\n│   └── hello-cdk-stack.ts\n├── test\n│   └── hello-cdk.test.ts\n├── cdk.json\n├── jest.config.js\n├── package.json\n└── tsconfig.json\n\nbin/hello-cdk.ts: Entry point for the CDK application\nlib/hello-cdk-stack.ts: Defines the main CDK stack with the Lambda function\ntest/hello-cdk.test.ts: Contains tests for the CDK stack (currently commented out)\ncdk.json: CDK configuration file\njest.config.js: Jest testing framework configuration\npackage.json: Node.js project configuration and dependencies\ntsconfig.json: TypeScript compiler configuration\n\n Usage Instructions\n Prerequisites\n\nNode.js (v14.x or later)\nAWS CLI configured with appropriate credentials\nAWS CDK CLI (v2.x)\n\n Installation\n\n\nClone the repository:\ngit clone <repository-url>\ncd hello-cdk\n\n\nInstall dependencies:\nnpm install\n\n\n Deploying the Stack\n\n\nSynthesize the CloudFormation template:\nnpx cdk synth\n\n\nDeploy the stack:\nnpx cdk deploy\n\n\nAfter deployment, the CDK will output the function URL. You can use this URL to invoke your Lambda function.\n Testing\nTo run the tests (once implemented):\nnpm test\n Modifying the Lambda Function\nThe Lambda function is defined inline in lib/hello-cdk-stack.ts. To modify its behavior, update the code within the lambda.Code.fromInline() method.\n Troubleshooting\n\n\nIssue: CDK deployment fails\n\nEnsure your AWS CLI is correctly configured with the appropriate permissions\nCheck the CloudFormation console for detailed error messages\nVerify that you have the latest version of the CDK CLI installed\n\n\n\nIssue: Lambda function returns an error\n\nCheck the CloudWatch logs for the Lambda function\nEnsure the function handler matches the one specified in the CDK stack\n\n\n\nIssue: Unable to invoke the Lambda function URL\n\nVerify that the function URL is correctly output after deployment\nEnsure your network allows outbound HTTPS connections\n\n\n\nFor more detailed debugging:\n\nEnable CDK debug logging:export CDK_DEBUG=true\n\nUse the --debug flag with CDK commands for verbose output\n\n Data Flow\n\nUser sends an HTTP request to the Lambda function URL\nAPI Gateway (managed by Lambda function URLs) receives the request and forwards it to the Lambda function\nLambda function executes, generating a \"Hello World\" response\nThe response is sent back through API Gateway to the user\n\n[User]->[Function URL]->[Lambda]->[Function URL]->[User]\nNote: The Lambda function in this project is simple and stateless. For more complex applications, you might introduce additional components like databases or other AWS services.\n Infrastructure\nThis project uses AWS CDK to define the following resources:\n Lambda\n\nHelloWorldFunction: A Node.js Lambda function that returns a \"Hello World\" message\n\nRuntime: Node.js 20.x\nHandler: index.handler\nCode: Defined inline in the CDK stack\n\n\n\n Lambda Function URL\n\nFunction URL: Provides HTTP(S) endpoint for the Lambda function\n\nAuth Type: NONE (public access)\n\n\n\n CloudFormation Outputs\n\nmyFunctionUrlOutput: The URL of the Lambda function, allowing easy access to the function's endpoint\n\nThe infrastructure is defined in the HelloCdkStack class within lib/hello-cdk-stack.ts.\n This project demonstrates how to create a simple \"Hello World\" Lambda function using AWS CDK with TypeScript. The AWS Cloud Development Kit (CDK) is an open-source software development framework to define cloud infrastructure in code and provision it through AWS CloudFormation. This project sets up a basic CDK application that deploys a Lambda function with a function URL, allowing you to invoke the function via HTTP requests. The Lambda function returns a simple \"Hello World\" message when invoked. This project serves as a starting point for more complex serverless applications and showcases the power of infrastructure as code using AWS CDK. .\n├── bin\n│   └── hello-cdk.ts\n├── lib\n│   └── hello-cdk-stack.ts\n├── test\n│   └── hello-cdk.test.ts\n├── cdk.json\n├── jest.config.js\n├── package.json\n└── tsconfig.json\n Clone the repository: git clone <repository-url>\ncd hello-cdk\n Install dependencies: npm install\n Synthesize the CloudFormation template: npx cdk synth\n Deploy the stack: npx cdk deploy\n After deployment, the CDK will output the function URL. You can use this URL to invoke your Lambda function. To run the tests (once implemented): npm test\n The Lambda function is defined inline in lib/hello-cdk-stack.ts. To modify its behavior, update the code within the lambda.Code.fromInline() method. Issue: CDK deployment fails Issue: Lambda function returns an error Issue: Unable to invoke the Lambda function URL For more detailed debugging: export CDK_DEBUG=true\n [User]->[Function URL]->[Lambda]->[Function URL]->[User]\n Note: The Lambda function in this project is simple and stateless. For more complex applications, you might introduce additional components like databases or other AWS services. This project uses AWS CDK to define the following resources: The infrastructure is defined in the HelloCdkStack class within lib/hello-cdk-stack.ts. Amazon Q Developer エージェントの新機能としてドキュメント生成が発表されたので試してみました。\n予想以上にきれいなドキュメントが生成されてびっくりしています。\nますます Amazon Q が日本語対応してくれるときが楽しみになりました！"
    },
    {
        "url": "https://qiita.com/har1101/items/b303e9105b29b9bdd525",
        "status": "success",
        "content": "re:Invent近辺のAWSアップデートを試してみる！Advent Calendar 2024Day 4@har1101Amazon Q Developerのドキュメント作成機能を使ってみた！AWSAmazonQreInvent2024Posted at 2024-12-04 re:Invent近辺のAWSアップデートを試してみる！Advent Calendar 2024 re:Invent近辺のAWSアップデートを試してみる！ Advent Calendar 2024 Day 4 @har1101 @har1101  Posted at 2024-12-04 Posted at 2024-12-04 \nやりたいこと\nBedrockの新機能、カスタムオーケストレーションリポジトリが公式のGitHub上に存在するのですが、1つ問題点があります。\n一切ドキュメントがない！！！READMEすらない！！！\n\n\n\nしかもこの機能めちゃくちゃ難しく、さらにリポジトリを見ても何をどうすればいいかよくわからない。\nだったらAmazon Q DeveloperにREADMEを作ってもらおうじゃないか！ということでやってみました！\n\nAmazon Q Developer Agentのドキュメント作成機能\n2024年12月3日、Amazon Q Developerはソースコード内でドキュメントを生成できるようになりました。\nこの機能によって、Amazon Q Developer Agentが手間のかかるドキュメント作成のタスクを処理するため、開発者はコードの作成と設計に集中できます。\n\n\n\n他にも、ユニットテスト作成機能や、コードレビュー機能も追加されています。まとめてブログ化されていました。\n総じて、開発者がよりコーディングに集中できるような仕組みが整ってきています。\n\n\n\n\n料金形態\nAmazon Q Developerの機能の一部なので、この機能を使うからと言って特別追加で料金がかかることはありません。\nAmazon Q Developerの料金形態としては、フリーティアとプロティアがあります。\nフリーはもちろん無料、プロは1ユーザーあたり19ドル/月です。\nフリーでも月10回呼び出せるそうなので、お試しするくらいなら無料で使えそうですね！\n詳しくは↓\n\n\n\n\nやってみる\nまずはVSCode上にリポジトリをクローンします。\n以下のコマンドをVSCodeのターミナルで叩きます。\ngit clone https://github.com/aws-samples/amazon-bedrock-samples.git\n\nこんな感じになればOKです。\n\n続いて、早速Amazon Q Developerの出番。\n\n\nAmazon Q Developerのインストール手順については、以下のブログをご参照ください。\nhttps://blog.serverworks.co.jp/2024/07/26/174241\n\n\n入力欄に「/(スラッシュ)」を打つと、Amazon Q Developerのどの機能を使うかが選べます。\n\n今回は /doc を選択し、エンターキーを押します。\n\nすると、ドキュメント生成モードに移行します。\n始めるには、Create a README か Update an existing fREADME かを選びます。\n今回は前者を選択。\n\nClaudeHandsonディレクトリのREADMEは不要なので、Change folderを選択。\n\n今回はもちろん、カスタムオーケストレーションのフォルダーを選択します。\n\n再度確認されるので、Yes を選択。\n\nすると、実行開始してくれます。\n実行手順としては、3段階あるようです。\n\nソースファイルの読み取り\nソースファイルの要約\nドキュメントの生成\n\n\n数分待つと完了し、実際にREADMEが生成されていました！\n\n実際に生成されたドキュメントはこちら(長いので折りたたんでいます)\n\nAmazon Bedrock Agent with Custom Orchestration\nThis project demonstrates how to create and use a Bedrock Agent with custom orchestration for managing restaurant bookings. It showcases the integration of AWS services like Lambda, DynamoDB, and Amazon Bedrock to create an intelligent conversational agent.\nThe custom orchestration feature allows for fine-grained control over the agent's behavior, enabling complex conversation flows and integration with external tools and services.\n\nRepository Structure\n\n\nagents.py: Main script for creating and managing Bedrock agents, including IAM roles and Lambda functions.\n\nknowledge_bases.py: Helper class for creating and managing Knowledge Bases for Amazon Bedrock.\n\nlambda_function.py: Lambda function for handling restaurant booking operations.\n\nlambda_rewoo.py: Custom orchestration Lambda function for the Bedrock agent.\n\ncustom_orchestrators_samples/: Directory containing sample custom orchestrators:\n\n\nlambda_react.js: JavaScript implementation of a React-based orchestrator.\n\nlambda_react.py: Python implementation of a React-based orchestrator.\n\nlambda_rewoo.js: JavaScript implementation of a ReWOO-based orchestrator.\n\n\n\n\nUsage Instructions\n\nPrerequisites\n\nAWS CLI configured with appropriate permissions\nPython 3.11 or later\nBoto3 library installed\nAccess to Amazon Bedrock and related services\n\n\nSetting Up the Environment\n\n\nClone the repository:\ngit clone <repository-url>\ncd amazon-bedrock-samples/agents-and-function-calling/bedrock-agents/features-examples/14-create-agent-with-custom-orchestration\n\n\n\nInstall required Python packages:\npip install boto3 opensearch-py retrying\n\n\n\nEnsure you have the necessary AWS permissions to create and manage Bedrock agents, Lambda functions, DynamoDB tables, and IAM roles.\n\n\n\nCreating a Bedrock Agent with Custom Orchestration\n\n\nModify the agents.py script to set your desired agent configuration:\n\nAgent name\nDescription\nFoundation model\nInstruction\nCustom orchestration Lambda function (if using)\n\n\n\nRun the agents.py script:\npython agents.py\n\n\n\nThe script will create:\n\nA DynamoDB table for storing restaurant bookings\nA Lambda function for handling booking operations\nIAM roles and policies\nA Bedrock agent with custom orchestration\n\n\n\n\nUsing the Agent\nOnce the agent is created, you can interact with it using the Bedrock Agent Runtime API or through the AWS Console. The agent can handle restaurant booking operations such as:\n\nCreating a new booking\nRetrieving booking details\nDeleting a booking\n\nExample interaction:\nresponse = bedrock_agent_runtime_client.invoke_agent(\n    agentId='your-agent-id',\n    agentAliasId='your-agent-alias-id',\n    sessionId='unique-session-id',\n    inputText='I want to book a table for 4 people tomorrow at 7 PM'\n)\nprint(response['completion'])\n\n\nData Flow\n\nUser input is received by the Bedrock Agent.\nThe custom orchestration Lambda function (lambda_rewoo.py or one of the samples in custom_orchestrators_samples/) processes the input and determines the next action.\nIf a booking operation is required, the orchestrator invokes the booking Lambda function (lambda_function.py).\nThe booking Lambda function interacts with the DynamoDB table to create, retrieve, or delete bookings.\nThe result is returned to the orchestrator, which then formulates a response.\nThe Bedrock Agent sends the final response back to the user.\n\nUser Input -> Bedrock Agent -> Custom Orchestrator -> Booking Lambda -> DynamoDB\n                    ^                    |\n                    |                    v\n                    User <---- Bedrock Agent <---- Custom Orchestrator\n\n\nTroubleshooting\n\nIf you encounter permission issues, ensure that the IAM roles have the correct policies attached.\nCheck CloudWatch Logs for Lambda function execution logs to debug any issues.\nVerify that the DynamoDB table is created correctly and accessible to the Lambda function.\n\n\nInfrastructure\nThe project uses the following AWS resources:\n\nLambda:\n\n\nlambda_function: Handles restaurant booking operations\nCustom orchestration Lambda (e.g., lambda_rewoo)\n\n\nDynamoDB:\n\nTable for storing restaurant bookings\n\n\nIAM:\n\nRoles for Lambda functions and Bedrock agent\n\n\nAmazon Bedrock:\n\nBedrock agent with custom orchestration\n\n\n\n\nDeployment\nThe agents.py script handles the deployment of all necessary resources. Ensure you have the required AWS permissions before running the script.\nFor production deployments, consider using AWS CloudFormation or AWS CDK to manage the infrastructure as code.\n\n日本語翻訳版はこちらです(長いので折りたたんでいます)\n\nカスタムオーケストレーションを使用したAmazon Bedrock Agent\nこのプロジェクトは、レストランの予約管理のためのカスタムオーケストレーション機能を持つBedrock Agentの作成方法と使用方法を示しています。Lambda、DynamoDB、Amazon BedrockなどのAWSサービスを統合して、インテリジェントな対話型エージェントを作成する方法を紹介します。\nカスタムオーケストレーション機能により、エージェントの動作を細かく制御でき、複雑な会話フローと外部ツールやサービスとの統合を実現できます。\n\nリポジトリ構造\n\n\nagents.py: Bedrockエージェントの作成と管理のためのメインスクリプト（IAMロールとLambda関数を含む）\n\nknowledge_bases.py: Amazon Bedrockのナレッジベースを作成・管理するためのヘルパークラス\n\nlambda_function.py: レストラン予約操作を処理するためのLambda関数\n\nlambda_rewoo.py: Bedrockエージェント用のカスタムオーケストレーションLambda関数\n\ncustom_orchestrators_samples/: サンプルカスタムオーケストレーターを含むディレクトリ：\n\n\nlambda_react.js: ReactベースのオーケストレーターのJavaScript実装\n\nlambda_react.py: ReactベースのオーケストレーターのPython実装\n\nlambda_rewoo.js: ReWOOベースのオーケストレーターのJavaScript実装\n\n\n\n\n使用方法\n\n前提条件\n\n適切な権限で設定されたAWS CLI\nPython 3.11以降\nBoto3ライブラリがインストールされていること\nAmazon Bedrockおよび関連サービスへのアクセス権限\n\n\n環境のセットアップ\n\n\nリポジトリをクローン：\ngit clone <repository-url>\ncd amazon-bedrock-samples/agents-and-function-calling/bedrock-agents/features-examples/14-create-agent-with-custom-orchestration\n\n\n\n必要なPythonパッケージをインストール：\npip install boto3 opensearch-py retrying\n\n\n\nBedrockエージェント、Lambda関数、DynamoDBテーブル、IAMロールを作成および管理するための必要なAWS権限があることを確認してください。\n\n\n\nカスタムオーケストレーション付きBedrockエージェントの作成\n\n\nagents.pyスクリプトを以下の設定で変更：\n\nエージェント名\n説明\n基盤モデル\nインストラクション\nカスタムオーケストレーションLambda関数（使用する場合）\n\n\n\nagents.pyスクリプトを実行：\npython agents.py\n\n\n\nスクリプトは以下を作成します：\n\nレストラン予約を保存するためのDynamoDBテーブル\n予約操作を処理するためのLambda関数\nIAMロールとポリシー\nカスタムオーケストレーション付きBedrockエージェント\n\n\n\n\nエージェントの使用\nエージェントが作成されたら、Bedrock Agent Runtime APIまたはAWSコンソールを使用して対話できます。エージェントは以下のようなレストラン予約操作を処理できます：\n\n新規予約の作成\n予約詳細の取得\n予約の削除\n\n対話例：\nresponse = bedrock_agent_runtime_client.invoke_agent(\n    agentId='your-agent-id',\n    agentAliasId='your-agent-alias-id',\n    sessionId='unique-session-id',\n    inputText='明日の午後7時に4人で予約したいです'\n)\nprint(response['completion'])\n\n\nデータフロー\n\nユーザー入力がBedrockエージェントによって受信されます。\nカスタムオーケストレーションLambda関数（lambda_rewoo.pyまたはcustom_orchestrators_samples/内のサンプルのいずれか）が入力を処理し、次のアクションを決定します。\n予約操作が必要な場合、オーケストレーターは予約Lambda関数（lambda_function.py）を呼び出します。\n予約Lambda関数はDynamoDBテーブルと連携して、予約の作成、取得、削除を行います。\n結果はオーケストレーターに返され、応答が作成されます。\nBedrockエージェントがユーザーに最終応答を送信します。\n\nユーザー入力 -> Bedrockエージェント -> カスタムオーケストレーター -> 予約Lambda -> DynamoDB\n                     ^                    |\n                     |                    v\n                     ユーザー <---- Bedrockエージェント <---- カスタムオーケストレーター\n\n\nトラブルシューティング\n\n権限の問題が発生した場合は、IAMロールに正しいポリシーが付与されていることを確認してください。\n問題をデバッグするには、CloudWatch LogsでLambda関数の実行ログを確認してください。\nDynamoDBテーブルが正しく作成され、Lambda関数からアクセス可能であることを確認してください。\n\n\nインフラストラクチャ\nこのプロジェクトは以下のAWSリソースを使用します：\n\nLambda：\n\n\nlambda_function: レストラン予約操作を処理\nカスタムオーケストレーションLambda（例：lambda_rewoo）\n\n\nDynamoDB：\n\nレストラン予約を保存するためのテーブル\n\n\nIAM：\n\nLambda関数とBedrockエージェント用のロール\n\n\nAmazon Bedrock：\n\nカスタムオーケストレーション付きBedrockエージェント\n\n\n\n\nデプロイメント\nagents.pyスクリプトが必要なリソースすべてのデプロイメントを処理します。スクリプトを実行する前に、必要なAWS権限があることを確認してください。\n本番環境へのデプロイメントでは、AWS CloudFormationまたはAWS CDKを使用してインフラストラクチャをコードとして管理することを検討してください。\n\nこれが一瞬で作られるって、もしかしたらとんでもない時代が来たかもしれません…\nちなみにですが、気に入らない場所があったら修正もしてくれるそうです。\n今回は Make change としてみます。\n\nここでは自由記述で依頼できるそうです。\n先ほど作成してくれたドキュメントの中で、\n「Creating a Bedrock Agent with Custom Orchestration がわかりにくかったので、1つ1つの手順をよりわかりやすく、丁寧に説明してください」\nと依頼してみます。\n\nすると再び思考し…\n\nREADMEがアップデートされました！\n\n変更箇所だけ抜き出してみます。\n更新された英語版(長いので折りたたんでいます)\n\nCreating a Bedrock Agent with Custom Orchestration\nThe process of creating a Bedrock Agent with custom orchestration involves several steps, each handled by functions in the agents.py script. Here's a detailed breakdown of the process:\n\n\nConfigure the agent settings:\nOpen the agents.py script and modify the following variables at the top of the script:\n\n\nagent_name: Choose a unique name for your agent\n\nagent_description: Provide a brief description of your agent's purpose\n\nagent_foundation_model: Specify the foundation model to use (e.g., \"anthropic.claude-v2\")\n\nagent_instruction: Define the primary instruction for your agent\n\ncustom_orchestration_lambda: Set to None if not using custom orchestration, or provide the Lambda function name if using custom orchestration\n\n\n\nCreate a DynamoDB table:\nThe script uses the create_dynamodb function to create a table for storing restaurant bookings. This table will be used by the booking Lambda function.\ncreate_dynamodb(table_name, 'booking_id')\n\n\n\nCreate an IAM role for the Lambda function:\nThe create_lambda_role function sets up an IAM role with the necessary permissions for the Lambda function to access DynamoDB and other required services.\nlambda_iam_role = create_lambda_role(agent_name)\n\n\n\nCreate the booking Lambda function:\nThe create_lambda function packages and deploys the Lambda function that handles booking operations.\nlambda_function = create_lambda(\n    lambda_function_name,\n    'lambda_function.py',\n    lambda_iam_role,\n    environment={'Variables': {'booking_table_name': table_name}}\n)\n\n\n\n(Optional) Create the custom orchestration Lambda function:\nIf using custom orchestration, another Lambda function is created to handle the orchestration logic.\ncustom_orchestration_lambda = create_lambda(\n    custom_orchestration_lambda_name,\n    'lambda_rewoo.py',\n    lambda_iam_role\n)\n\n\n\nCreate an IAM role for the Bedrock Agent:\nThe script sets up an IAM role that allows the Bedrock Agent to invoke Lambda functions and access other necessary resources.\n\n\nCreate the Bedrock Agent:\nThe create_agent_object function is called to create the Bedrock Agent with the specified configuration, including custom orchestration if enabled.\nagent_id = create_agent_object(\n    agent_name, agent_role, agent_description,\n    idle_session_ttl_in_seconds, agent_foundation_model,\n    agent_instruction, custom_orchestration_lambda, None\n)\n\n\n\nCreate an alias for the Bedrock Agent:\nAn alias is created for the agent to make it easier to manage different versions.\nalias_id = bedrock_agent_client.create_agent_alias(\n    agentId=agent_id,\n    agentAliasName=f'{agent_name}-alias'\n)['agentAlias']['agentAliasId']\n\n\n\nRun the script:\nExecute the agents.py script to create all the necessary resources and the Bedrock Agent:\npython agents.py\n\nThe script will output progress information and any errors encountered during the creation process.\n\n\nVerify the agent creation:\nAfter the script completes, you can verify the agent's creation in the AWS Console or by using the Bedrock Agent API.\n\n\nBy following these steps, you'll create a Bedrock Agent with custom orchestration, including all the necessary AWS resources like DynamoDB tables, Lambda functions, and IAM roles. The agent will be ready to handle restaurant booking operations using the custom logic defined in the orchestration Lambda function.\n\n更新された日本語版(長いので折りたたんでいます)\n\n環境のセットアップ\n\n\nリポジトリをクローン：\ngit clone <repository-url>\ncd amazon-bedrock-samples/agents-and-function-calling/bedrock-agents/features-examples/14-create-agent-with-custom-orchestration\n\n\n\n必要なPythonパッケージをインストール：\npip install boto3 opensearch-py retrying\n\n\n\nBedrockエージェント、Lambda関数、DynamoDBテーブル、IAMロールの作成と管理に必要なAWS権限があることを確認してください。\n\n\n\nカスタムオーケストレーション付きBedrockエージェントの作成\nカスタムオーケストレーション付きBedrockエージェントの作成プロセスは、agents.pyスクリプト内の関数によって処理される複数のステップで構成されています。以下に詳細な手順を説明します：\n\n\nエージェント設定の構成：\nagents.pyスクリプトを開き、スクリプト上部の以下の変数を変更します：\n\n\nagent_name：エージェントの一意の名前を選択\n\nagent_description：エージェントの目的の簡単な説明\n\nagent_foundation_model：使用する基盤モデルを指定（例：「anthropic.claude-v2」）\n\nagent_instruction：エージェントの主要な指示を定義\n\ncustom_orchestration_lambda：カスタムオーケストレーションを使用しない場合はNone、使用する場合はLambda関数名を指定\n\n\n\nDynamoDBテーブルの作成：\nスクリプトはcreate_dynamodb関数を使用してレストラン予約保存用のテーブルを作成します。このテーブルは予約Lambda関数によって使用されます。\ncreate_dynamodb(table_name, 'booking_id')\n\n\n\nLambda関数用のIAMロールの作成：\ncreate_lambda_role関数は、Lambda関数がDynamoDBやその他の必要なサービスにアクセスするために必要な権限を持つIAMロールを設定します。\nlambda_iam_role = create_lambda_role(agent_name)\n\n\n\n予約Lambda関数の作成：\ncreate_lambda関数は、予約操作を処理するLambda関数をパッケージ化してデプロイします。\nlambda_function = create_lambda(\n    lambda_function_name,\n    'lambda_function.py',\n    lambda_iam_role,\n    environment={'Variables': {'booking_table_name': table_name}}\n)\n\n\n\n（オプション）カスタムオーケストレーションLambda関数の作成：\nカスタムオーケストレーションを使用する場合、オーケストレーションロジックを処理する別のLambda関数が作成されます。\ncustom_orchestration_lambda = create_lambda(\n    custom_orchestration_lambda_name,\n    'lambda_rewoo.py',\n    lambda_iam_role\n)\n\n\n\nBedrockエージェントのIAMロールの作成：\nスクリプトは、BedrockエージェントがLambda関数を呼び出し、他の必要なリソースにアクセスできるようにするIAMロールを設定します。\n\n\nBedrockエージェントの作成：\ncreate_agent_object関数を呼び出して、カスタムオーケストレーション（有効な場合）を含む指定された設定でBedrockエージェントを作成します。\nagent_id = create_agent_object(\n    agent_name, agent_role, agent_description,\n    idle_session_ttl_in_seconds, agent_foundation_model,\n    agent_instruction, custom_orchestration_lambda, None\n)\n\n\n\nBedrockエージェントのエイリアスの作成：\n異なるバージョンを簡単に管理できるように、エージェントのエイリアスを作成します。\nalias_id = bedrock_agent_client.create_agent_alias(\n    agentId=agent_id,\n    agentAliasName=f'{agent_name}-alias'\n)['agentAlias']['agentAliasId']\n\n\n\nスクリプトの実行：\n必要なリソースとBedrockエージェントを作成するために、agents.pyスクリプトを実行します：\npython agents.py\n\nスクリプトは作成プロセス中の進行状況とエラー（もしあれば）を出力します。\n\n\nエージェント作成の確認：\nスクリプトの完了後、AWSコンソールまたはBedrock Agent APIを使用してエージェントの作成を確認できます。\n\n\nこれらの手順に従うことで、DynamoDBテーブル、Lambda関数、IAMロールなどの必要なAWSリソースを含む、カスタムオーケストレーション付きBedrockエージェントが作成されます。エージェントはオーケストレーションLambda関数で定義されたカスタムロジックを使用してレストラン予約操作を処理できる状態になります。\n\nめ、めっちゃ詳細に解説してくれてる〜〜〜！！！\nということでこれでOKでしょう！Accept します！\n\nあっさりとREADMEが完成しました！\n\nこれを実際に試すのはまた別記事で！\n\nまとめ\nめちゃくちゃ簡単にREADMEを作成してくれました！\nここまで来ると、最早こんなに簡単でいいのか？って感じです。\n技術的負債の解消に一役買ってくれそうな機能だと思います！\nあとは、もっと大規模で複雑なシステムになった時にどこまで正確に解釈して文字起こししてくれるか、でしょうか…\n今後の動向にも注目です！\n \nやりたいこと\nBedrockの新機能、カスタムオーケストレーションリポジトリが公式のGitHub上に存在するのですが、1つ問題点があります。\n一切ドキュメントがない！！！READMEすらない！！！\n\n\n\nしかもこの機能めちゃくちゃ難しく、さらにリポジトリを見ても何をどうすればいいかよくわからない。\nだったらAmazon Q DeveloperにREADMEを作ってもらおうじゃないか！ということでやってみました！\n\nAmazon Q Developer Agentのドキュメント作成機能\n2024年12月3日、Amazon Q Developerはソースコード内でドキュメントを生成できるようになりました。\nこの機能によって、Amazon Q Developer Agentが手間のかかるドキュメント作成のタスクを処理するため、開発者はコードの作成と設計に集中できます。\n\n\n\n他にも、ユニットテスト作成機能や、コードレビュー機能も追加されています。まとめてブログ化されていました。\n総じて、開発者がよりコーディングに集中できるような仕組みが整ってきています。\n\n\n\n\n料金形態\nAmazon Q Developerの機能の一部なので、この機能を使うからと言って特別追加で料金がかかることはありません。\nAmazon Q Developerの料金形態としては、フリーティアとプロティアがあります。\nフリーはもちろん無料、プロは1ユーザーあたり19ドル/月です。\nフリーでも月10回呼び出せるそうなので、お試しするくらいなら無料で使えそうですね！\n詳しくは↓\n\n\n\n\nやってみる\nまずはVSCode上にリポジトリをクローンします。\n以下のコマンドをVSCodeのターミナルで叩きます。\ngit clone https://github.com/aws-samples/amazon-bedrock-samples.git\n\nこんな感じになればOKです。\n\n続いて、早速Amazon Q Developerの出番。\n\n\nAmazon Q Developerのインストール手順については、以下のブログをご参照ください。\nhttps://blog.serverworks.co.jp/2024/07/26/174241\n\n\n入力欄に「/(スラッシュ)」を打つと、Amazon Q Developerのどの機能を使うかが選べます。\n\n今回は /doc を選択し、エンターキーを押します。\n\nすると、ドキュメント生成モードに移行します。\n始めるには、Create a README か Update an existing fREADME かを選びます。\n今回は前者を選択。\n\nClaudeHandsonディレクトリのREADMEは不要なので、Change folderを選択。\n\n今回はもちろん、カスタムオーケストレーションのフォルダーを選択します。\n\n再度確認されるので、Yes を選択。\n\nすると、実行開始してくれます。\n実行手順としては、3段階あるようです。\n\nソースファイルの読み取り\nソースファイルの要約\nドキュメントの生成\n\n\n数分待つと完了し、実際にREADMEが生成されていました！\n\n実際に生成されたドキュメントはこちら(長いので折りたたんでいます)\n\nAmazon Bedrock Agent with Custom Orchestration\nThis project demonstrates how to create and use a Bedrock Agent with custom orchestration for managing restaurant bookings. It showcases the integration of AWS services like Lambda, DynamoDB, and Amazon Bedrock to create an intelligent conversational agent.\nThe custom orchestration feature allows for fine-grained control over the agent's behavior, enabling complex conversation flows and integration with external tools and services.\n\nRepository Structure\n\n\nagents.py: Main script for creating and managing Bedrock agents, including IAM roles and Lambda functions.\n\nknowledge_bases.py: Helper class for creating and managing Knowledge Bases for Amazon Bedrock.\n\nlambda_function.py: Lambda function for handling restaurant booking operations.\n\nlambda_rewoo.py: Custom orchestration Lambda function for the Bedrock agent.\n\ncustom_orchestrators_samples/: Directory containing sample custom orchestrators:\n\n\nlambda_react.js: JavaScript implementation of a React-based orchestrator.\n\nlambda_react.py: Python implementation of a React-based orchestrator.\n\nlambda_rewoo.js: JavaScript implementation of a ReWOO-based orchestrator.\n\n\n\n\nUsage Instructions\n\nPrerequisites\n\nAWS CLI configured with appropriate permissions\nPython 3.11 or later\nBoto3 library installed\nAccess to Amazon Bedrock and related services\n\n\nSetting Up the Environment\n\n\nClone the repository:\ngit clone <repository-url>\ncd amazon-bedrock-samples/agents-and-function-calling/bedrock-agents/features-examples/14-create-agent-with-custom-orchestration\n\n\n\nInstall required Python packages:\npip install boto3 opensearch-py retrying\n\n\n\nEnsure you have the necessary AWS permissions to create and manage Bedrock agents, Lambda functions, DynamoDB tables, and IAM roles.\n\n\n\nCreating a Bedrock Agent with Custom Orchestration\n\n\nModify the agents.py script to set your desired agent configuration:\n\nAgent name\nDescription\nFoundation model\nInstruction\nCustom orchestration Lambda function (if using)\n\n\n\nRun the agents.py script:\npython agents.py\n\n\n\nThe script will create:\n\nA DynamoDB table for storing restaurant bookings\nA Lambda function for handling booking operations\nIAM roles and policies\nA Bedrock agent with custom orchestration\n\n\n\n\nUsing the Agent\nOnce the agent is created, you can interact with it using the Bedrock Agent Runtime API or through the AWS Console. The agent can handle restaurant booking operations such as:\n\nCreating a new booking\nRetrieving booking details\nDeleting a booking\n\nExample interaction:\nresponse = bedrock_agent_runtime_client.invoke_agent(\n    agentId='your-agent-id',\n    agentAliasId='your-agent-alias-id',\n    sessionId='unique-session-id',\n    inputText='I want to book a table for 4 people tomorrow at 7 PM'\n)\nprint(response['completion'])\n\n\nData Flow\n\nUser input is received by the Bedrock Agent.\nThe custom orchestration Lambda function (lambda_rewoo.py or one of the samples in custom_orchestrators_samples/) processes the input and determines the next action.\nIf a booking operation is required, the orchestrator invokes the booking Lambda function (lambda_function.py).\nThe booking Lambda function interacts with the DynamoDB table to create, retrieve, or delete bookings.\nThe result is returned to the orchestrator, which then formulates a response.\nThe Bedrock Agent sends the final response back to the user.\n\nUser Input -> Bedrock Agent -> Custom Orchestrator -> Booking Lambda -> DynamoDB\n                    ^                    |\n                    |                    v\n                    User <---- Bedrock Agent <---- Custom Orchestrator\n\n\nTroubleshooting\n\nIf you encounter permission issues, ensure that the IAM roles have the correct policies attached.\nCheck CloudWatch Logs for Lambda function execution logs to debug any issues.\nVerify that the DynamoDB table is created correctly and accessible to the Lambda function.\n\n\nInfrastructure\nThe project uses the following AWS resources:\n\nLambda:\n\n\nlambda_function: Handles restaurant booking operations\nCustom orchestration Lambda (e.g., lambda_rewoo)\n\n\nDynamoDB:\n\nTable for storing restaurant bookings\n\n\nIAM:\n\nRoles for Lambda functions and Bedrock agent\n\n\nAmazon Bedrock:\n\nBedrock agent with custom orchestration\n\n\n\n\nDeployment\nThe agents.py script handles the deployment of all necessary resources. Ensure you have the required AWS permissions before running the script.\nFor production deployments, consider using AWS CloudFormation or AWS CDK to manage the infrastructure as code.\n\n日本語翻訳版はこちらです(長いので折りたたんでいます)\n\nカスタムオーケストレーションを使用したAmazon Bedrock Agent\nこのプロジェクトは、レストランの予約管理のためのカスタムオーケストレーション機能を持つBedrock Agentの作成方法と使用方法を示しています。Lambda、DynamoDB、Amazon BedrockなどのAWSサービスを統合して、インテリジェントな対話型エージェントを作成する方法を紹介します。\nカスタムオーケストレーション機能により、エージェントの動作を細かく制御でき、複雑な会話フローと外部ツールやサービスとの統合を実現できます。\n\nリポジトリ構造\n\n\nagents.py: Bedrockエージェントの作成と管理のためのメインスクリプト（IAMロールとLambda関数を含む）\n\nknowledge_bases.py: Amazon Bedrockのナレッジベースを作成・管理するためのヘルパークラス\n\nlambda_function.py: レストラン予約操作を処理するためのLambda関数\n\nlambda_rewoo.py: Bedrockエージェント用のカスタムオーケストレーションLambda関数\n\ncustom_orchestrators_samples/: サンプルカスタムオーケストレーターを含むディレクトリ：\n\n\nlambda_react.js: ReactベースのオーケストレーターのJavaScript実装\n\nlambda_react.py: ReactベースのオーケストレーターのPython実装\n\nlambda_rewoo.js: ReWOOベースのオーケストレーターのJavaScript実装\n\n\n\n\n使用方法\n\n前提条件\n\n適切な権限で設定されたAWS CLI\nPython 3.11以降\nBoto3ライブラリがインストールされていること\nAmazon Bedrockおよび関連サービスへのアクセス権限\n\n\n環境のセットアップ\n\n\nリポジトリをクローン：\ngit clone <repository-url>\ncd amazon-bedrock-samples/agents-and-function-calling/bedrock-agents/features-examples/14-create-agent-with-custom-orchestration\n\n\n\n必要なPythonパッケージをインストール：\npip install boto3 opensearch-py retrying\n\n\n\nBedrockエージェント、Lambda関数、DynamoDBテーブル、IAMロールを作成および管理するための必要なAWS権限があることを確認してください。\n\n\n\nカスタムオーケストレーション付きBedrockエージェントの作成\n\n\nagents.pyスクリプトを以下の設定で変更：\n\nエージェント名\n説明\n基盤モデル\nインストラクション\nカスタムオーケストレーションLambda関数（使用する場合）\n\n\n\nagents.pyスクリプトを実行：\npython agents.py\n\n\n\nスクリプトは以下を作成します：\n\nレストラン予約を保存するためのDynamoDBテーブル\n予約操作を処理するためのLambda関数\nIAMロールとポリシー\nカスタムオーケストレーション付きBedrockエージェント\n\n\n\n\nエージェントの使用\nエージェントが作成されたら、Bedrock Agent Runtime APIまたはAWSコンソールを使用して対話できます。エージェントは以下のようなレストラン予約操作を処理できます：\n\n新規予約の作成\n予約詳細の取得\n予約の削除\n\n対話例：\nresponse = bedrock_agent_runtime_client.invoke_agent(\n    agentId='your-agent-id',\n    agentAliasId='your-agent-alias-id',\n    sessionId='unique-session-id',\n    inputText='明日の午後7時に4人で予約したいです'\n)\nprint(response['completion'])\n\n\nデータフロー\n\nユーザー入力がBedrockエージェントによって受信されます。\nカスタムオーケストレーションLambda関数（lambda_rewoo.pyまたはcustom_orchestrators_samples/内のサンプルのいずれか）が入力を処理し、次のアクションを決定します。\n予約操作が必要な場合、オーケストレーターは予約Lambda関数（lambda_function.py）を呼び出します。\n予約Lambda関数はDynamoDBテーブルと連携して、予約の作成、取得、削除を行います。\n結果はオーケストレーターに返され、応答が作成されます。\nBedrockエージェントがユーザーに最終応答を送信します。\n\nユーザー入力 -> Bedrockエージェント -> カスタムオーケストレーター -> 予約Lambda -> DynamoDB\n                     ^                    |\n                     |                    v\n                     ユーザー <---- Bedrockエージェント <---- カスタムオーケストレーター\n\n\nトラブルシューティング\n\n権限の問題が発生した場合は、IAMロールに正しいポリシーが付与されていることを確認してください。\n問題をデバッグするには、CloudWatch LogsでLambda関数の実行ログを確認してください。\nDynamoDBテーブルが正しく作成され、Lambda関数からアクセス可能であることを確認してください。\n\n\nインフラストラクチャ\nこのプロジェクトは以下のAWSリソースを使用します：\n\nLambda：\n\n\nlambda_function: レストラン予約操作を処理\nカスタムオーケストレーションLambda（例：lambda_rewoo）\n\n\nDynamoDB：\n\nレストラン予約を保存するためのテーブル\n\n\nIAM：\n\nLambda関数とBedrockエージェント用のロール\n\n\nAmazon Bedrock：\n\nカスタムオーケストレーション付きBedrockエージェント\n\n\n\n\nデプロイメント\nagents.pyスクリプトが必要なリソースすべてのデプロイメントを処理します。スクリプトを実行する前に、必要なAWS権限があることを確認してください。\n本番環境へのデプロイメントでは、AWS CloudFormationまたはAWS CDKを使用してインフラストラクチャをコードとして管理することを検討してください。\n\nこれが一瞬で作られるって、もしかしたらとんでもない時代が来たかもしれません…\nちなみにですが、気に入らない場所があったら修正もしてくれるそうです。\n今回は Make change としてみます。\n\nここでは自由記述で依頼できるそうです。\n先ほど作成してくれたドキュメントの中で、\n「Creating a Bedrock Agent with Custom Orchestration がわかりにくかったので、1つ1つの手順をよりわかりやすく、丁寧に説明してください」\nと依頼してみます。\n\nすると再び思考し…\n\nREADMEがアップデートされました！\n\n変更箇所だけ抜き出してみます。\n更新された英語版(長いので折りたたんでいます)\n\nCreating a Bedrock Agent with Custom Orchestration\nThe process of creating a Bedrock Agent with custom orchestration involves several steps, each handled by functions in the agents.py script. Here's a detailed breakdown of the process:\n\n\nConfigure the agent settings:\nOpen the agents.py script and modify the following variables at the top of the script:\n\n\nagent_name: Choose a unique name for your agent\n\nagent_description: Provide a brief description of your agent's purpose\n\nagent_foundation_model: Specify the foundation model to use (e.g., \"anthropic.claude-v2\")\n\nagent_instruction: Define the primary instruction for your agent\n\ncustom_orchestration_lambda: Set to None if not using custom orchestration, or provide the Lambda function name if using custom orchestration\n\n\n\nCreate a DynamoDB table:\nThe script uses the create_dynamodb function to create a table for storing restaurant bookings. This table will be used by the booking Lambda function.\ncreate_dynamodb(table_name, 'booking_id')\n\n\n\nCreate an IAM role for the Lambda function:\nThe create_lambda_role function sets up an IAM role with the necessary permissions for the Lambda function to access DynamoDB and other required services.\nlambda_iam_role = create_lambda_role(agent_name)\n\n\n\nCreate the booking Lambda function:\nThe create_lambda function packages and deploys the Lambda function that handles booking operations.\nlambda_function = create_lambda(\n    lambda_function_name,\n    'lambda_function.py',\n    lambda_iam_role,\n    environment={'Variables': {'booking_table_name': table_name}}\n)\n\n\n\n(Optional) Create the custom orchestration Lambda function:\nIf using custom orchestration, another Lambda function is created to handle the orchestration logic.\ncustom_orchestration_lambda = create_lambda(\n    custom_orchestration_lambda_name,\n    'lambda_rewoo.py',\n    lambda_iam_role\n)\n\n\n\nCreate an IAM role for the Bedrock Agent:\nThe script sets up an IAM role that allows the Bedrock Agent to invoke Lambda functions and access other necessary resources.\n\n\nCreate the Bedrock Agent:\nThe create_agent_object function is called to create the Bedrock Agent with the specified configuration, including custom orchestration if enabled.\nagent_id = create_agent_object(\n    agent_name, agent_role, agent_description,\n    idle_session_ttl_in_seconds, agent_foundation_model,\n    agent_instruction, custom_orchestration_lambda, None\n)\n\n\n\nCreate an alias for the Bedrock Agent:\nAn alias is created for the agent to make it easier to manage different versions.\nalias_id = bedrock_agent_client.create_agent_alias(\n    agentId=agent_id,\n    agentAliasName=f'{agent_name}-alias'\n)['agentAlias']['agentAliasId']\n\n\n\nRun the script:\nExecute the agents.py script to create all the necessary resources and the Bedrock Agent:\npython agents.py\n\nThe script will output progress information and any errors encountered during the creation process.\n\n\nVerify the agent creation:\nAfter the script completes, you can verify the agent's creation in the AWS Console or by using the Bedrock Agent API.\n\n\nBy following these steps, you'll create a Bedrock Agent with custom orchestration, including all the necessary AWS resources like DynamoDB tables, Lambda functions, and IAM roles. The agent will be ready to handle restaurant booking operations using the custom logic defined in the orchestration Lambda function.\n\n更新された日本語版(長いので折りたたんでいます)\n\n環境のセットアップ\n\n\nリポジトリをクローン：\ngit clone <repository-url>\ncd amazon-bedrock-samples/agents-and-function-calling/bedrock-agents/features-examples/14-create-agent-with-custom-orchestration\n\n\n\n必要なPythonパッケージをインストール：\npip install boto3 opensearch-py retrying\n\n\n\nBedrockエージェント、Lambda関数、DynamoDBテーブル、IAMロールの作成と管理に必要なAWS権限があることを確認してください。\n\n\n\nカスタムオーケストレーション付きBedrockエージェントの作成\nカスタムオーケストレーション付きBedrockエージェントの作成プロセスは、agents.pyスクリプト内の関数によって処理される複数のステップで構成されています。以下に詳細な手順を説明します：\n\n\nエージェント設定の構成：\nagents.pyスクリプトを開き、スクリプト上部の以下の変数を変更します：\n\n\nagent_name：エージェントの一意の名前を選択\n\nagent_description：エージェントの目的の簡単な説明\n\nagent_foundation_model：使用する基盤モデルを指定（例：「anthropic.claude-v2」）\n\nagent_instruction：エージェントの主要な指示を定義\n\ncustom_orchestration_lambda：カスタムオーケストレーションを使用しない場合はNone、使用する場合はLambda関数名を指定\n\n\n\nDynamoDBテーブルの作成：\nスクリプトはcreate_dynamodb関数を使用してレストラン予約保存用のテーブルを作成します。このテーブルは予約Lambda関数によって使用されます。\ncreate_dynamodb(table_name, 'booking_id')\n\n\n\nLambda関数用のIAMロールの作成：\ncreate_lambda_role関数は、Lambda関数がDynamoDBやその他の必要なサービスにアクセスするために必要な権限を持つIAMロールを設定します。\nlambda_iam_role = create_lambda_role(agent_name)\n\n\n\n予約Lambda関数の作成：\ncreate_lambda関数は、予約操作を処理するLambda関数をパッケージ化してデプロイします。\nlambda_function = create_lambda(\n    lambda_function_name,\n    'lambda_function.py',\n    lambda_iam_role,\n    environment={'Variables': {'booking_table_name': table_name}}\n)\n\n\n\n（オプション）カスタムオーケストレーションLambda関数の作成：\nカスタムオーケストレーションを使用する場合、オーケストレーションロジックを処理する別のLambda関数が作成されます。\ncustom_orchestration_lambda = create_lambda(\n    custom_orchestration_lambda_name,\n    'lambda_rewoo.py',\n    lambda_iam_role\n)\n\n\n\nBedrockエージェントのIAMロールの作成：\nスクリプトは、BedrockエージェントがLambda関数を呼び出し、他の必要なリソースにアクセスできるようにするIAMロールを設定します。\n\n\nBedrockエージェントの作成：\ncreate_agent_object関数を呼び出して、カスタムオーケストレーション（有効な場合）を含む指定された設定でBedrockエージェントを作成します。\nagent_id = create_agent_object(\n    agent_name, agent_role, agent_description,\n    idle_session_ttl_in_seconds, agent_foundation_model,\n    agent_instruction, custom_orchestration_lambda, None\n)\n\n\n\nBedrockエージェントのエイリアスの作成：\n異なるバージョンを簡単に管理できるように、エージェントのエイリアスを作成します。\nalias_id = bedrock_agent_client.create_agent_alias(\n    agentId=agent_id,\n    agentAliasName=f'{agent_name}-alias'\n)['agentAlias']['agentAliasId']\n\n\n\nスクリプトの実行：\n必要なリソースとBedrockエージェントを作成するために、agents.pyスクリプトを実行します：\npython agents.py\n\nスクリプトは作成プロセス中の進行状況とエラー（もしあれば）を出力します。\n\n\nエージェント作成の確認：\nスクリプトの完了後、AWSコンソールまたはBedrock Agent APIを使用してエージェントの作成を確認できます。\n\n\nこれらの手順に従うことで、DynamoDBテーブル、Lambda関数、IAMロールなどの必要なAWSリソースを含む、カスタムオーケストレーション付きBedrockエージェントが作成されます。エージェントはオーケストレーションLambda関数で定義されたカスタムロジックを使用してレストラン予約操作を処理できる状態になります。\n\nめ、めっちゃ詳細に解説してくれてる〜〜〜！！！\nということでこれでOKでしょう！Accept します！\n\nあっさりとREADMEが完成しました！\n\nこれを実際に試すのはまた別記事で！\n\nまとめ\nめちゃくちゃ簡単にREADMEを作成してくれました！\nここまで来ると、最早こんなに簡単でいいのか？って感じです。\n技術的負債の解消に一役買ってくれそうな機能だと思います！\nあとは、もっと大規模で複雑なシステムになった時にどこまで正確に解釈して文字起こししてくれるか、でしょうか…\n今後の動向にも注目です！\n  Bedrockの新機能、カスタムオーケストレーションリポジトリが公式のGitHub上に存在するのですが、1つ問題点があります。 一切ドキュメントがない！！！READMEすらない！！！ \n\n しかもこの機能めちゃくちゃ難しく、さらにリポジトリを見ても何をどうすればいいかよくわからない。 だったらAmazon Q DeveloperにREADMEを作ってもらおうじゃないか！ということでやってみました！  2024年12月3日、Amazon Q Developerはソースコード内でドキュメントを生成できるようになりました。\nこの機能によって、Amazon Q Developer Agentが手間のかかるドキュメント作成のタスクを処理するため、開発者はコードの作成と設計に集中できます。 \n\n 他にも、ユニットテスト作成機能や、コードレビュー機能も追加されています。まとめてブログ化されていました。\n総じて、開発者がよりコーディングに集中できるような仕組みが整ってきています。 \n\n  Amazon Q Developerの機能の一部なので、この機能を使うからと言って特別追加で料金がかかることはありません。 Amazon Q Developerの料金形態としては、フリーティアとプロティアがあります。\nフリーはもちろん無料、プロは1ユーザーあたり19ドル/月です。 フリーでも月10回呼び出せるそうなので、お試しするくらいなら無料で使えそうですね！\n詳しくは↓ \n\n  まずはVSCode上にリポジトリをクローンします。\n以下のコマンドをVSCodeのターミナルで叩きます。 git clone https://github.com/aws-samples/amazon-bedrock-samples.git\n git clone https://github.com/aws-samples/amazon-bedrock-samples.git\n こんな感じになればOKです。\n 続いて、早速Amazon Q Developerの出番。 \n\nAmazon Q Developerのインストール手順については、以下のブログをご参照ください。\nhttps://blog.serverworks.co.jp/2024/07/26/174241\n\n  \nAmazon Q Developerのインストール手順については、以下のブログをご参照ください。\nhttps://blog.serverworks.co.jp/2024/07/26/174241\n Amazon Q Developerのインストール手順については、以下のブログをご参照ください。\nhttps://blog.serverworks.co.jp/2024/07/26/174241 入力欄に「/(スラッシュ)」を打つと、Amazon Q Developerのどの機能を使うかが選べます。\n 今回は /doc を選択し、エンターキーを押します。\n すると、ドキュメント生成モードに移行します。\n始めるには、Create a README か Update an existing fREADME かを選びます。\n今回は前者を選択。\n ClaudeHandsonディレクトリのREADMEは不要なので、Change folderを選択。\n 今回はもちろん、カスタムオーケストレーションのフォルダーを選択します。\n 再度確認されるので、Yes を選択。\n すると、実行開始してくれます。\n実行手順としては、3段階あるようです。  数分待つと完了し、実際にREADMEが生成されていました！\n  This project demonstrates how to create and use a Bedrock Agent with custom orchestration for managing restaurant bookings. It showcases the integration of AWS services like Lambda, DynamoDB, and Amazon Bedrock to create an intelligent conversational agent. The custom orchestration feature allows for fine-grained control over the agent's behavior, enabling complex conversation flows and integration with external tools and services.     Clone the repository: git clone <repository-url>\ncd amazon-bedrock-samples/agents-and-function-calling/bedrock-agents/features-examples/14-create-agent-with-custom-orchestration\n git clone <repository-url>\ncd amazon-bedrock-samples/agents-and-function-calling/bedrock-agents/features-examples/14-create-agent-with-custom-orchestration\n Install required Python packages: pip install boto3 opensearch-py retrying\n pip install boto3 opensearch-py retrying\n Ensure you have the necessary AWS permissions to create and manage Bedrock agents, Lambda functions, DynamoDB tables, and IAM roles.  Modify the agents.py script to set your desired agent configuration: Run the agents.py script: python agents.py\n python agents.py\n The script will create:  Once the agent is created, you can interact with it using the Bedrock Agent Runtime API or through the AWS Console. The agent can handle restaurant booking operations such as: Example interaction: response = bedrock_agent_runtime_client.invoke_agent(\n    agentId='your-agent-id',\n    agentAliasId='your-agent-alias-id',\n    sessionId='unique-session-id',\n    inputText='I want to book a table for 4 people tomorrow at 7 PM'\n)\nprint(response['completion'])\n response = bedrock_agent_runtime_client.invoke_agent(\n    agentId='your-agent-id',\n    agentAliasId='your-agent-alias-id',\n    sessionId='unique-session-id',\n    inputText='I want to book a table for 4 people tomorrow at 7 PM'\n)\nprint(response['completion'])\n response = bedrock_agent_runtime_client . invoke_agent ( agentId = ' your-agent-id ' , agentAliasId = ' your-agent-alias-id ' , sessionId = ' unique-session-id ' , inputText = ' I want to book a table for 4 people tomorrow at 7 PM ' ) print ( response [ ' completion ' ])  User Input -> Bedrock Agent -> Custom Orchestrator -> Booking Lambda -> DynamoDB\n                    ^                    |\n                    |                    v\n                    User <---- Bedrock Agent <---- Custom Orchestrator\n User Input -> Bedrock Agent -> Custom Orchestrator -> Booking Lambda -> DynamoDB\n                    ^                    |\n                    |                    v\n                    User <---- Bedrock Agent <---- Custom Orchestrator\n   The project uses the following AWS resources:  The agents.py script handles the deployment of all necessary resources. Ensure you have the required AWS permissions before running the script. For production deployments, consider using AWS CloudFormation or AWS CDK to manage the infrastructure as code.  このプロジェクトは、レストランの予約管理のためのカスタムオーケストレーション機能を持つBedrock Agentの作成方法と使用方法を示しています。Lambda、DynamoDB、Amazon BedrockなどのAWSサービスを統合して、インテリジェントな対話型エージェントを作成する方法を紹介します。 カスタムオーケストレーション機能により、エージェントの動作を細かく制御でき、複雑な会話フローと外部ツールやサービスとの統合を実現できます。     リポジトリをクローン： git clone <repository-url>\ncd amazon-bedrock-samples/agents-and-function-calling/bedrock-agents/features-examples/14-create-agent-with-custom-orchestration\n git clone <repository-url>\ncd amazon-bedrock-samples/agents-and-function-calling/bedrock-agents/features-examples/14-create-agent-with-custom-orchestration\n 必要なPythonパッケージをインストール： pip install boto3 opensearch-py retrying\n pip install boto3 opensearch-py retrying\n Bedrockエージェント、Lambda関数、DynamoDBテーブル、IAMロールを作成および管理するための必要なAWS権限があることを確認してください。  agents.pyスクリプトを以下の設定で変更： agents.pyスクリプトを実行： python agents.py\n python agents.py\n スクリプトは以下を作成します：  エージェントが作成されたら、Bedrock Agent Runtime APIまたはAWSコンソールを使用して対話できます。エージェントは以下のようなレストラン予約操作を処理できます： 対話例： response = bedrock_agent_runtime_client.invoke_agent(\n    agentId='your-agent-id',\n    agentAliasId='your-agent-alias-id',\n    sessionId='unique-session-id',\n    inputText='明日の午後7時に4人で予約したいです'\n)\nprint(response['completion'])\n response = bedrock_agent_runtime_client.invoke_agent(\n    agentId='your-agent-id',\n    agentAliasId='your-agent-alias-id',\n    sessionId='unique-session-id',\n    inputText='明日の午後7時に4人で予約したいです'\n)\nprint(response['completion'])\n response = bedrock_agent_runtime_client . invoke_agent ( agentId = ' your-agent-id ' , agentAliasId = ' your-agent-alias-id ' , sessionId = ' unique-session-id ' , inputText = ' 明日の午後7時に4人で予約したいです ' ) print ( response [ ' completion ' ])  ユーザー入力 -> Bedrockエージェント -> カスタムオーケストレーター -> 予約Lambda -> DynamoDB\n                     ^                    |\n                     |                    v\n                     ユーザー <---- Bedrockエージェント <---- カスタムオーケストレーター\n ユーザー入力 -> Bedrockエージェント -> カスタムオーケストレーター -> 予約Lambda -> DynamoDB\n                     ^                    |\n                     |                    v\n                     ユーザー <---- Bedrockエージェント <---- カスタムオーケストレーター\n   このプロジェクトは以下のAWSリソースを使用します：  agents.pyスクリプトが必要なリソースすべてのデプロイメントを処理します。スクリプトを実行する前に、必要なAWS権限があることを確認してください。 本番環境へのデプロイメントでは、AWS CloudFormationまたはAWS CDKを使用してインフラストラクチャをコードとして管理することを検討してください。 これが一瞬で作られるって、もしかしたらとんでもない時代が来たかもしれません… ちなみにですが、気に入らない場所があったら修正もしてくれるそうです。\n今回は Make change としてみます。\n ここでは自由記述で依頼できるそうです。\n先ほど作成してくれたドキュメントの中で、\n「Creating a Bedrock Agent with Custom Orchestration がわかりにくかったので、1つ1つの手順をよりわかりやすく、丁寧に説明してください」\nと依頼してみます。\n すると再び思考し…\n READMEがアップデートされました！\n 変更箇所だけ抜き出してみます。  The process of creating a Bedrock Agent with custom orchestration involves several steps, each handled by functions in the agents.py script. Here's a detailed breakdown of the process: Configure the agent settings:\nOpen the agents.py script and modify the following variables at the top of the script: Create a DynamoDB table:\nThe script uses the create_dynamodb function to create a table for storing restaurant bookings. This table will be used by the booking Lambda function. create_dynamodb(table_name, 'booking_id')\n create_dynamodb(table_name, 'booking_id')\n create_dynamodb ( table_name , ' booking_id ' ) Create an IAM role for the Lambda function:\nThe create_lambda_role function sets up an IAM role with the necessary permissions for the Lambda function to access DynamoDB and other required services. lambda_iam_role = create_lambda_role(agent_name)\n lambda_iam_role = create_lambda_role(agent_name)\n lambda_iam_role = create_lambda_role ( agent_name ) Create the booking Lambda function:\nThe create_lambda function packages and deploys the Lambda function that handles booking operations. lambda_function = create_lambda(\n    lambda_function_name,\n    'lambda_function.py',\n    lambda_iam_role,\n    environment={'Variables': {'booking_table_name': table_name}}\n)\n lambda_function = create_lambda(\n    lambda_function_name,\n    'lambda_function.py',\n    lambda_iam_role,\n    environment={'Variables': {'booking_table_name': table_name}}\n)\n lambda_function = create_lambda ( lambda_function_name , ' lambda_function.py ' , lambda_iam_role , environment = { ' Variables ' : { ' booking_table_name ' : table_name }} ) (Optional) Create the custom orchestration Lambda function:\nIf using custom orchestration, another Lambda function is created to handle the orchestration logic. custom_orchestration_lambda = create_lambda(\n    custom_orchestration_lambda_name,\n    'lambda_rewoo.py',\n    lambda_iam_role\n)\n custom_orchestration_lambda = create_lambda(\n    custom_orchestration_lambda_name,\n    'lambda_rewoo.py',\n    lambda_iam_role\n)\n custom_orchestration_lambda = create_lambda ( custom_orchestration_lambda_name , ' lambda_rewoo.py ' , lambda_iam_role ) Create an IAM role for the Bedrock Agent:\nThe script sets up an IAM role that allows the Bedrock Agent to invoke Lambda functions and access other necessary resources. Create the Bedrock Agent:\nThe create_agent_object function is called to create the Bedrock Agent with the specified configuration, including custom orchestration if enabled. agent_id = create_agent_object(\n    agent_name, agent_role, agent_description,\n    idle_session_ttl_in_seconds, agent_foundation_model,\n    agent_instruction, custom_orchestration_lambda, None\n)\n agent_id = create_agent_object(\n    agent_name, agent_role, agent_description,\n    idle_session_ttl_in_seconds, agent_foundation_model,\n    agent_instruction, custom_orchestration_lambda, None\n)\n agent_id = create_agent_object ( agent_name , agent_role , agent_description , idle_session_ttl_in_seconds , agent_foundation_model , agent_instruction , custom_orchestration_lambda , None ) Create an alias for the Bedrock Agent:\nAn alias is created for the agent to make it easier to manage different versions. alias_id = bedrock_agent_client.create_agent_alias(\n    agentId=agent_id,\n    agentAliasName=f'{agent_name}-alias'\n)['agentAlias']['agentAliasId']\n alias_id = bedrock_agent_client.create_agent_alias(\n    agentId=agent_id,\n    agentAliasName=f'{agent_name}-alias'\n)['agentAlias']['agentAliasId']\n alias_id = bedrock_agent_client . create_agent_alias ( agentId = agent_id , agentAliasName = f ' { agent_name } -alias ' )[ ' agentAlias ' ][ ' agentAliasId ' ] Run the script:\nExecute the agents.py script to create all the necessary resources and the Bedrock Agent: python agents.py\n python agents.py\n The script will output progress information and any errors encountered during the creation process. Verify the agent creation:\nAfter the script completes, you can verify the agent's creation in the AWS Console or by using the Bedrock Agent API. By following these steps, you'll create a Bedrock Agent with custom orchestration, including all the necessary AWS resources like DynamoDB tables, Lambda functions, and IAM roles. The agent will be ready to handle restaurant booking operations using the custom logic defined in the orchestration Lambda function.  リポジトリをクローン： git clone <repository-url>\ncd amazon-bedrock-samples/agents-and-function-calling/bedrock-agents/features-examples/14-create-agent-with-custom-orchestration\n git clone <repository-url>\ncd amazon-bedrock-samples/agents-and-function-calling/bedrock-agents/features-examples/14-create-agent-with-custom-orchestration\n 必要なPythonパッケージをインストール： pip install boto3 opensearch-py retrying\n pip install boto3 opensearch-py retrying\n Bedrockエージェント、Lambda関数、DynamoDBテーブル、IAMロールの作成と管理に必要なAWS権限があることを確認してください。  カスタムオーケストレーション付きBedrockエージェントの作成プロセスは、agents.pyスクリプト内の関数によって処理される複数のステップで構成されています。以下に詳細な手順を説明します： エージェント設定の構成：\nagents.pyスクリプトを開き、スクリプト上部の以下の変数を変更します： DynamoDBテーブルの作成：\nスクリプトはcreate_dynamodb関数を使用してレストラン予約保存用のテーブルを作成します。このテーブルは予約Lambda関数によって使用されます。 create_dynamodb(table_name, 'booking_id')\n create_dynamodb(table_name, 'booking_id')\n create_dynamodb ( table_name , ' booking_id ' ) Lambda関数用のIAMロールの作成：\ncreate_lambda_role関数は、Lambda関数がDynamoDBやその他の必要なサービスにアクセスするために必要な権限を持つIAMロールを設定します。 lambda_iam_role = create_lambda_role(agent_name)\n lambda_iam_role = create_lambda_role(agent_name)\n lambda_iam_role = create_lambda_role ( agent_name ) 予約Lambda関数の作成：\ncreate_lambda関数は、予約操作を処理するLambda関数をパッケージ化してデプロイします。 lambda_function = create_lambda(\n    lambda_function_name,\n    'lambda_function.py',\n    lambda_iam_role,\n    environment={'Variables': {'booking_table_name': table_name}}\n)\n lambda_function = create_lambda(\n    lambda_function_name,\n    'lambda_function.py',\n    lambda_iam_role,\n    environment={'Variables': {'booking_table_name': table_name}}\n)\n lambda_function = create_lambda ( lambda_function_name , ' lambda_function.py ' , lambda_iam_role , environment = { ' Variables ' : { ' booking_table_name ' : table_name }} ) （オプション）カスタムオーケストレーションLambda関数の作成：\nカスタムオーケストレーションを使用する場合、オーケストレーションロジックを処理する別のLambda関数が作成されます。 custom_orchestration_lambda = create_lambda(\n    custom_orchestration_lambda_name,\n    'lambda_rewoo.py',\n    lambda_iam_role\n)\n custom_orchestration_lambda = create_lambda(\n    custom_orchestration_lambda_name,\n    'lambda_rewoo.py',\n    lambda_iam_role\n)\n custom_orchestration_lambda = create_lambda ( custom_orchestration_lambda_name , ' lambda_rewoo.py ' , lambda_iam_role ) BedrockエージェントのIAMロールの作成：\nスクリプトは、BedrockエージェントがLambda関数を呼び出し、他の必要なリソースにアクセスできるようにするIAMロールを設定します。 Bedrockエージェントの作成：\ncreate_agent_object関数を呼び出して、カスタムオーケストレーション（有効な場合）を含む指定された設定でBedrockエージェントを作成します。 agent_id = create_agent_object(\n    agent_name, agent_role, agent_description,\n    idle_session_ttl_in_seconds, agent_foundation_model,\n    agent_instruction, custom_orchestration_lambda, None\n)\n agent_id = create_agent_object(\n    agent_name, agent_role, agent_description,\n    idle_session_ttl_in_seconds, agent_foundation_model,\n    agent_instruction, custom_orchestration_lambda, None\n)\n agent_id = create_agent_object ( agent_name , agent_role , agent_description , idle_session_ttl_in_seconds , agent_foundation_model , agent_instruction , custom_orchestration_lambda , None ) Bedrockエージェントのエイリアスの作成：\n異なるバージョンを簡単に管理できるように、エージェントのエイリアスを作成します。 alias_id = bedrock_agent_client.create_agent_alias(\n    agentId=agent_id,\n    agentAliasName=f'{agent_name}-alias'\n)['agentAlias']['agentAliasId']\n alias_id = bedrock_agent_client.create_agent_alias(\n    agentId=agent_id,\n    agentAliasName=f'{agent_name}-alias'\n)['agentAlias']['agentAliasId']\n alias_id = bedrock_agent_client . create_agent_alias ( agentId = agent_id , agentAliasName = f ' { agent_name } -alias ' )[ ' agentAlias ' ][ ' agentAliasId ' ] スクリプトの実行：\n必要なリソースとBedrockエージェントを作成するために、agents.pyスクリプトを実行します： python agents.py\n python agents.py\n スクリプトは作成プロセス中の進行状況とエラー（もしあれば）を出力します。 エージェント作成の確認：\nスクリプトの完了後、AWSコンソールまたはBedrock Agent APIを使用してエージェントの作成を確認できます。 これらの手順に従うことで、DynamoDBテーブル、Lambda関数、IAMロールなどの必要なAWSリソースを含む、カスタムオーケストレーション付きBedrockエージェントが作成されます。エージェントはオーケストレーションLambda関数で定義されたカスタムロジックを使用してレストラン予約操作を処理できる状態になります。 め、めっちゃ詳細に解説してくれてる〜〜〜！！！ ということでこれでOKでしょう！Accept します！\n あっさりとREADMEが完成しました！\n これを実際に試すのはまた別記事で！  めちゃくちゃ簡単にREADMEを作成してくれました！\nここまで来ると、最早こんなに簡単でいいのか？って感じです。 技術的負債の解消に一役買ってくれそうな機能だと思います！\nあとは、もっと大規模で複雑なシステムになった時にどこまで正確に解釈して文字起こししてくれるか、でしょうか… 今後の動向にも注目です！ 1Go to list of users who liked0comment0Go to list of comments 1Go to list of users who liked0comment0Go to list of comments 1Go to list of users who liked  1Go to list of users who liked 1Go to list of users who liked Go to list of users who liked 0 0 comment0Go to list of comments comment Go to list of comments  Register as a new user and use Qiita more convenientlyYou get articles that match your needsYou can efficiently read back useful informationYou can use dark themeWhat you can do with signing upSign upLogin Register as a new user and use Qiita more conveniently Sign upLogin"
    },
    {
        "url": "https://qiita.com/yoshimi0227/items/336d2d1d9cd50c050754",
        "status": "success",
        "content": "NRI OpenStandiaAdvent Calendar 2024Day 10@yoshimi0227in株式会社野村総合研究所[検証] Amazon Q Developerのドキュメント＆ユニットテスト自動生成機能はどこまで手動作成クオリティに近づくのかJavaAWSunittestdocumentationAmazonQLast updated at 2024-12-10Posted at 2024-12-09 NRI OpenStandiaAdvent Calendar 2024 NRI OpenStandia Advent Calendar 2024 Day 10 @yoshimi0227in株式会社野村総合研究所 @yoshimi0227in株式会社野村総合研究所  in株式会社野村総合研究所 in 株式会社野村総合研究所 Last updated at 2024-12-10Posted at 2024-12-09 Last updated at 2024-12-10 Posted at 2024-12-09 \nはじめに\nこちらはNRI OpenStandia Advent Calendar 2024の10日目の記事です。\nAWS re:Invent 2024にて、Amazon Q Developerのアップデートとして「コードに基づいたドキュメント自動生成」機能と「コードに基づいたユニットテスト自動生成」機能が発表されました。\n\n\n\n\n\n\nAmazon Q Developerは、AWS社のコードやドキュメントをもとに学習が行われています。つまり、「自動生成されるドキュメント」と「自動生成されるユニットテスト」はAWS本家が手動作成しているドキュメントやユニットテストと同じようなクオリティになるのではないでしょうか。\nそこで、今回はAWS社から出しているOSSを題材として、どのようなドキュメントやユニットテストが自動生成されていくかを見ていこうと思います。\n\nAmazon Q Developerとは\nAmazon Q Developerは運用開発者がVSCodeやIntelliJ等のコードエディタを用いてコーディングする際に、生成AIによるアシストをしてくれるツールです。\nアシスト例はこちらです。\n\nコーディング時に、リアルタイムでコードを補完\nチャット上で自然言語（例：日本語、英語）を用いてQA回答\n\n/devコマンドをトリガーとして、リアルタイムで実装コードを提案\n\n/transformコマンドをトリガーとして、Javaのレガシーコードのアップデート方法を提示\n\n/reviewコマンドをトリガーとして、コードレビュー機能にて脆弱性やリスクを特定し、緩和策も提示\n\n/docコマンドをトリガーとして、ドキュメントを自動生成（※本記事での検証１）\n\n/testコマンドをトリガーとして、ユニットテストを自動生成（※本記事の検証２）\n\n\n検証\n\n検証に用いるAWS本家のソースコード\nJava検証用にServerless Java container、Python検証用にaws-cliをピックアップしました。\n\n\n\n\n\n\n\n検証方法\n\n該当コードをcloneします\n自動生成する予定のファイルを全部削除します\n\n検証1：README、フォルダ内に存在するドキュメント（例：docフォルダ配下すべて）\n検証2：フォルダ内に存在するテスト（例：testフォルダ配下すべて）\n\n\n\n/docコマンド or /testコマンドを実行します\n\n\n/docコマンドはコマンドを叩いたあとにREADMEを自動生成したいリポジトリを選択します\n\n/testコマンドはユニットテストを自動作成したいファイルをあらかじめアクティブ状態にしてからコマンドを叩く必要があります\n\n\n\n\n検証1：/docコマンドをトリガーとして、ドキュメントを自動生成\n\nServerless Java containerの検証結果\nServerless Java containerの実行結果はこちらです。公式のREADMEとは異なる全く異なるアウトプットであることから、「Amazon Q Developerは過学習していない（個別最適化されないように、大量のデータを学習している）」ということがわかります。\n\n中身を詳しく見ていきます。まずREADMEの目次構成は下記のようになっていました。READMEの構成として、存在すると便利な項目が綺麗に並んでおり、READMEとしての有用性が高くなっております。\n\nREADME.md の目次構成\nAWS Serverless Java Container（タイトル）\n├　Repository Structure（リポジトリ内のモジュール構成）\n├　Usage Instructions（使い方）\n│├　Installation（インストール方法）\n│├　Getting Started（インストール後の使い方）\n│├　Configuration（使う際の設定について）\n│├　Common Use Cases（主なユースケース）\n│├　Testing（テスト実行方法）\n│└　Troubleshooting（トラブルシューティング）\n├　Data Flow（データの流れ）\n├　Deployment（デプロイ方法）\n└　Infrastructure（インフラ構成）\n\n\nそれぞれの項目も、コマンドベースで丁寧に記載がされていました。また、内容もおおむね「一般的に正しいことが多い」回答となっておりました。\n例えば、トラブルシューティングの章は一般的な対応方法が記載されています。インストールの章も同じくです。\nなお、インストールバージョンに関しては、「Prerequisites」で指定されているバージョンよりも古いバージョン（例：Java17）も本OSSは利用可能と思われます。と言いますのも、本OSSはgithubのワークフロー設定（.github/workflows/continuous-integration-workflow.yml）にてJava17を指定しています。\nただ最新LTSであるJava21を推奨しているのは個人的には悪くないと思います。アシスタントする生成AI側で明確に推奨バージョンを判別できない場合、一般的には新しいLTSを使う方が推奨されるため、回答として「明確な」間違いとなる可能性が低いためです。\n\nREADME.md（一部抜粋：Installation）\n### Installation\n\nPrerequisites:\n- Java 21 or later\n- Maven 3.6.3 or later\n- AWS CLI configured with appropriate credentials\n\nTo install the AWS Serverless Java Container, clone the repository and build the project:\n\n---\ngit clone https://github.com/aws/serverless-java-container.git\ncd serverless-java-container\nmvn clean install\n---\n\n\n\nREADME.md（一部抜粋：Troubleshooting）\n### Troubleshooting\n\nCommon issues and solutions:\n\n1. ClassNotFoundException:\n   - Ensure all dependencies are correctly specified in your `pom.xml` file.\n   - Check that the `Handler` property in your `template.yml` file points to the correct class.\n\n2. API Gateway errors:\n   - Verify that your API routes are correctly defined in your application code.\n   - Check the CloudWatch logs for your Lambda function for any error messages.\n\n3. Performance issues:\n   - Consider using the `async` initialization option for faster cold starts.\n   - Optimize your application code and reduce the number of dependencies.\n\n\n\naws-cliの検証結果\nもう一つの検証対象であるaws-cliも見ていきます。READMEの目次構成は下記の通りです。\nこの目次は、Serverless Java containerのREADME自動生成の結果と完全一致はしていないものの、かなり似ております。このことから、裏側で動いている生成AI側である程度READMEの目次フォーマットを決めていることが推測できます。\n\nREADME.md の目次構成\nAWS Command Line Interface (CLI)（タイトル）\n├　Repository Structure（リポジトリ内のフォルダ構成、主要なファイル）\n├　Usage Instructions（使い方）\n│├　Installation（インストール方法）\n│├　Configuration（使う際の設定について）\n│├　Basic Usage（インストール後の基本的な使い方）\n│└　Getting Help（使い方のヘルプコマンド）\n├　Data Flow（データの流れ）\n├　Deployment（デプロイされている形式）\n├　Infrastructure（インフラ構成）\n├　Testing & Quality（テスト方法）\n├　Troubleshooting（トラブルシューティング）\n└　Performance Optimization（パフォーマンスの最適化）\n\n\n記載内容もおおむね正しいです。Repository Structureは検証のためにdocフォルダを削除しているためそれが記載されていないのは想定通りです。ドキュメント以外のフォルダは主要なものを問題なくピックアップできております。（awscliフォルダ配下にtopicsフォルダがあることを紹介できておりませんが、これは後述する「READMEの修正」で修正可能な範囲です。）\n\nREADME.md（一部抜粋：Repository Structure）\n## Repository Structure\n\nThe repository is organized as follows:\n\n- `aws-cli/`: Main directory containing the AWS CLI source code\n  - `awscli/`: Core AWS CLI implementation\n    - `customizations/`: Custom commands and behaviors for specific AWS services\n    - `data/`: Configuration data files\n    - `examples/`: Example files and templates\n  - `bin/`: Executable scripts\n  - `scripts/`: Utility scripts for development and testing\n  - `tests/`: Test suite for the AWS CLI\n\nKey Files:\n- `aws-cli/awscli/__main__.py`: Entry point for the AWS CLI\n- `aws-cli/awscli/clidriver.py`: Main driver for the CLI functionality\n- `aws-cli/setup.py`: Setup script for installing the AWS CLI\n\n\nまた、InstallationにおいてPythonのバージョンが3.8以上である必要があることは、setup.pyの記載とも一致します。\n\n\nREADME.md（一部抜粋：Installation）\n### Installation\n\n1. Ensure you have Python 3.8 or later installed.\n2. Install the AWS CLI using pip:\n\n---\npip install awscli\n---\n\n\n実際のところは、aws-cliのインストール方法は多岐にわたります。これらの情報も加味するには、別途手動で追加することになりそうです。\nなお、ここまで初回生成のREADMEを見ていきましたが、このREADMEはプロンプト指示をだすことによる修正が可能です。\n例えば、セクションの追加や削除、特定の文章自体の修正が可能です。この際、変更したいセクションや追加削除したいコンテンツ、文章の修正方針は明確に記述する必要があります。また、参照する必要があるものは、参照先がコードである必要があります。\nまた、READMEをより良いものとするためにAWS公式からベストプラクティスが提供されています。\nhttps://docs.aws.amazon.com/amazonq/latest/qdeveloper-ug/doc-generation-best-practices.html\n\n検証2：/testコマンドをトリガーとして、ユニットテストを自動生成\n/testコマンドを実行すると下記のような画面を見ることができます。なお、2024/12現在はJavaとPythonのみが対応となっております。ここでは文量の都合でaws-cliの検証結果のみ紹介します。\n\n\naws-cliの検証結果\n下記ファイルの単体テストを行いました。\nhttps://github.com/aws/aws-cli/blob/develop/awscli/customizations/s3/fileinfo.py\n該当ファイルには、下記4つのメソッドがあります。\n\n__init__(self, src, dest, compare_key, size, last_update, src_type, dest_type, operation_name, client, parameters, source_client, is_stream, associated_response_data)\nis_glacier_compatible(self)\n_is_glacier_object(self, response_data)\n_is_restored(self, response_data)\n\n生成されたテストケース一覧は下記の通りです。対象メソッド1つ1つに対して、正常ケースだけでなく異常ケースもしっかり検討されており、パターンも多く揃っております。（※番号1と3でまったく同じで何も記載のないテストが生成されていますが、この程度の余分なテストは削除する手間もたいしてないので、問題ないかと思っております。）\n\n\n\n＃\nテストメソッド\nテストの説明\nテスト対象メソッド\n\n\n\n\n1\ntest__is_glacier_object_1\n既存のテスト（変更なし）\n_is_glacier_object\n\n\n2\ntest__is_glacier_object_2\n非Glacierオブジェクトの場合にFalseを返すことをテスト\n_is_glacier_object\n\n\n3\ntest__is_glacier_object_3\n既存のテスト（変更なし）\n_is_glacier_object\n\n\n4\ntest__is_restored_with_case_sensitive_restore_value\n大文字小文字を区別するRestore値でのテスト\n_is_restored\n\n\n5\ntest__is_restored_with_empty_input\n空の入力での_is_restoredメソッドのテスト\n_is_restored\n\n\n6\ntest__is_restored_with_empty_restore_value\n空のRestore値での_is_restoredメソッドのテスト\n_is_restored\n\n\n7\ntest__is_restored_with_incorrect_type\n不正な入力タイプでの_is_restoredメソッドのテスト\n_is_restored\n\n\n8\ntest__is_restored_with_invalid_restore_value\n無効なRestore値での_is_restoredメソッドのテスト\n_is_restored\n\n\n9\ntest__is_restored_with_missing_restore_key\nRestoreキーが欠落している場合の_is_restoredメソッドのテスト\n_is_restored\n\n\n10\ntest__is_restored_with_none_input\nNone入力での_is_restoredメソッドのテスト\n_is_restored\n\n\n11\ntest__is_restored_with_ongoing_request\n進行中のリクエストでの_is_restoredメソッドのテスト\n_is_restored\n\n\n12\ntest__is_restored_with_partial_restore_value\n部分的なRestore値での_is_restoredメソッドのテスト\n_is_restored\n\n\n13\ntest_init_with_all_parameters\nすべてのパラメータを指定してFileInfoを初期化するテスト\n__init__\n\n\n14\ntest_init_with_default_parameters\nデフォルトパラメータでのFileInfo初期化テスト\n__init__\n\n\n15\ntest_init_with_empty_src\n空のsrcパラメータでの初期化テスト\n__init__\n\n\n16\ntest_init_with_invalid_associated_response_data\n無効なassociated_response_dataでの初期化テスト\n__init__\n\n\n17\ntest_init_with_invalid_dest_type\n無効なdest_typeパラメータでの初期化テスト\n__init__\n\n\n18\ntest_init_with_invalid_is_stream\n無効なis_streamパラメータでの初期化テスト\n__init__\n\n\n19\ntest_init_with_invalid_last_update\n無効なlast_updateパラメータでの初期化テスト\n__init__\n\n\n20\ntest_init_with_invalid_operation_name\n無効なoperation_nameパラメータでの初期化テスト\n__init__\n\n\n21\ntest_init_with_invalid_parameters_type\n無効なparameters型での初期化テスト\n__init__\n\n\n22\ntest_init_with_invalid_src_type\n無効なsrc_typeパラメータでの初期化テスト\n__init__\n\n\n23\ntest_init_with_negative_size\n負のsizeパラメータでの初期化テスト\n__init__\n\n\n24\ntest_init_with_parameters\nパラメータを指定してFileInfoを初期化するテスト\n__init__\n\n\n25\ntest_is_glacier_compatible_1\nGlacierオブジェクトのダウンロード操作の互換性テスト\nis_glacier_compatible\n\n\n26\ntest_is_glacier_compatible_3\nGlacierオブジェクトの削除操作の互換性テスト\nis_glacier_compatible\n\n\n27\ntest_is_glacier_compatible_deep_archive_object\nDeep Archiveオブジェクトの互換性テスト\nis_glacier_compatible\n\n\n28\ntest_is_glacier_compatible_glacier_object_copy\nGlacierオブジェクトのコピー操作の互換性テスト\nis_glacier_compatible\n\n\n29\ntest_is_glacier_compatible_glacier_object_download\nGlacierオブジェクトのダウンロード操作の互換性テスト\nis_glacier_compatible\n\n\n30\ntest_is_glacier_compatible_glacier_object_move_local_source\nローカルソースのGlacierオブジェクトの移動操作の互換性テスト\nis_glacier_compatible\n\n\n31\ntest_is_glacier_compatible_glacier_object_move_s3_source\nS3ソースのGlacierオブジェクトの移動操作の互換性テスト\nis_glacier_compatible\n\n\n32\ntest_is_glacier_compatible_glacier_upload\nGlacierオブジェクトのアップロード操作の互換性テスト\nis_glacier_compatible\n\n\n33\ntest_is_glacier_compatible_invalid_storage_class\n無効なストレージクラスでの互換性テスト\nis_glacier_compatible\n\n\n34\ntest_is_glacier_compatible_move_from_s3_glacier\nS3 Glacierからの移動操作の互換性テスト\nis_glacier_compatible\n\n\n35\ntest_is_glacier_compatible_no_associated_response_data\n関連レスポンスデータがない場合の互換性テスト\nis_glacier_compatible\n\n\n36\ntest_is_glacier_compatible_non_glacier_object\n非Glacierオブジェクトの互換性テスト\nis_glacier_compatible\n\n\n37\ntest_is_glacier_compatible_non_glacier_object_2\n別の非Glacierオブジェクトの互換性テスト\nis_glacier_compatible\n\n\n38\ntest_is_glacier_compatible_restored_glacier_object\n復元されたGlacierオブジェクトの互換性テスト\nis_glacier_compatible\n\n\n39\ntest_is_glacier_object_case_sensitivity\nストレージクラスの大文字小文字の区別テスト\n_is_glacier_object\n\n\n40\ntest_is_glacier_object_copy_operation\nGlacierオブジェクトのコピー操作のテスト\n_is_glacier_object\n\n\n41\ntest_is_glacier_object_deep_archive\nDeep Archiveストレージクラスの判定テスト\n_is_glacier_object\n\n\n42\ntest_is_glacier_object_empty_input\n空の入力での_is_glacier_objectメソッドのテスト\n_is_glacier_object\n\n\n43\ntest_is_glacier_object_incorrect_type\n不正な入力タイプでの_is_glacier_objectメソッドのテスト\n_is_glacier_object\n\n\n44\ntest_is_glacier_object_invalid_storage_class\n無効なストレージクラスでの_is_glacier_objectメソッドのテスト\n_is_glacier_object\n\n\n45\ntest_is_glacier_object_missing_storage_class\nストレージクラスが欠落している場合の_is_glacier_objectメソッドのテスト\n_is_glacier_object\n\n\n46\ntest_is_glacier_object_restored_glacier\n復元されたGlacierオブジェクトの_is_glacier_objectメソッドのテスト\n_is_glacier_object\n\n\n47\ntest_is_glacier_object_returns_false_for_empty_response_data\n空のレスポンスデータでの_is_glacier_objectメソッドのテスト\n_is_glacier_object\n\n\n48\ntest_is_glacier_object_returns_false_for_non_glacier_storage_class\n非Glacierストレージクラスでの_is_glacier_objectメソッドのテスト\n_is_glacier_object\n\n\n49\ntest_is_glacier_object_returns_false_for_none_response_data\nNoneレスポンスデータでの_is_glacier_objectメソッドのテスト\n_is_glacier_object\n\n\n50\ntest_is_glacier_object_returns_false_for_restored_glacier_object\n復元されたGlacierオブジェクトでの_is_glacier_objectメソッドのテスト\n_is_glacier_object\n\n\n51\ntest_is_glacier_object_returns_true_for_deep_archive_storage_class\nDeep Archiveストレージクラスでの_is_glacier_objectメソッドのテスト\n_is_glacier_object\n\n\n52\ntest_is_glacier_object_returns_true_for_glacier_storage_class\nGlacierストレージクラスでの_is_glacier_objectメソッドのテスト\n_is_glacier_object\n\n\n53\ntest_is_glacier_object_with_no_response_data\nレスポンスデータがない場合の_is_glacier_objectメソッドのテスト\n_is_glacier_object\n\n\n54\ntest_is_restored_when_object_is_not_restored\nオブジェクトが復元されていない場合の_is_restoredメソッドのテスト\n_is_restored\n\n\n55\ntest_is_restored_when_object_is_restored\nオブジェクトが復元された場合の_is_restoredメソッドのテスト\n_is_restored\n\n\n56\ntest_is_restored_when_restore_info_is_missing\n復元情報が欠落している場合の_is_restoredメソッドのテスト\n_is_restored\n\n\n\nテストメソッドを一部抜粋します。こちらの中身のロジックも問題なさそうです。\n\ntest_fileinfo.py（一部抜粋：6 空のRestore値での_is_restoredメソッドのテスト）\n    def test__is_restored_with_empty_restore_value(self):\n        \"\"\"\n        Test _is_restored method with empty Restore value\n        \"\"\"\n        file_info = FileInfo(src='test')\n        response_data = {'Restore': ''}\n        assert not file_info._is_restored(response_data)\n\n\n\ntest_fileinfo.py（一部抜粋：51 Deep Archiveストレージクラスでの_is_glacier_objectメソッドのテスト）\n    def test_is_glacier_object_returns_true_for_deep_archive_storage_class(self):\n        \"\"\"\n        Test that _is_glacier_object returns True for a DEEP_ARCHIVE storage class\n        that is not restored.\n        \"\"\"\n        file_info = FileInfo(src='dummy_src')\n        response_data = {\n            'StorageClass': 'DEEP_ARCHIVE',\n            'Restore': 'ongoing-request=\"true\"'\n        }\n        \n        result = file_info._is_glacier_object(response_data)\n        \n        assert result == True\n\n\nなお、本家のtest_fileinfo.pyファイルは下記の通りです。本家のユニットテストコードはより見やすいですね。とはいえ自動生成も健闘しているとは思うので、さらなる発展を期待します。\nhttps://github.com/aws/aws-cli/blob/develop/tests/unit/customizations/s3/test_fileinfo.py\n\nさいごに\n予想よりもドキュメント自動作成、ユニットテスト自動生成のクオリティが高かったため、活用できる箇所にはぜひ活用していきたいなと思いました。\nまた、ドキュメント自動生成にはサービスクォータがありますのでご注意ください！\n\n\n（参考）サービスクォータ\n\n既存のREADMEの最大サイズ：15KB\nREADMEを作成するプロジェクトに格納されているコードサイズ：200MB（非圧縮の場合）、50MB（圧縮の場合）\nタスクごとのドキュメント生成数：3\n\n\n\n \nはじめに\nこちらはNRI OpenStandia Advent Calendar 2024の10日目の記事です。\nAWS re:Invent 2024にて、Amazon Q Developerのアップデートとして「コードに基づいたドキュメント自動生成」機能と「コードに基づいたユニットテスト自動生成」機能が発表されました。\n\n\n\n\n\n\nAmazon Q Developerは、AWS社のコードやドキュメントをもとに学習が行われています。つまり、「自動生成されるドキュメント」と「自動生成されるユニットテスト」はAWS本家が手動作成しているドキュメントやユニットテストと同じようなクオリティになるのではないでしょうか。\nそこで、今回はAWS社から出しているOSSを題材として、どのようなドキュメントやユニットテストが自動生成されていくかを見ていこうと思います。\n\nAmazon Q Developerとは\nAmazon Q Developerは運用開発者がVSCodeやIntelliJ等のコードエディタを用いてコーディングする際に、生成AIによるアシストをしてくれるツールです。\nアシスト例はこちらです。\n\nコーディング時に、リアルタイムでコードを補完\nチャット上で自然言語（例：日本語、英語）を用いてQA回答\n\n/devコマンドをトリガーとして、リアルタイムで実装コードを提案\n\n/transformコマンドをトリガーとして、Javaのレガシーコードのアップデート方法を提示\n\n/reviewコマンドをトリガーとして、コードレビュー機能にて脆弱性やリスクを特定し、緩和策も提示\n\n/docコマンドをトリガーとして、ドキュメントを自動生成（※本記事での検証１）\n\n/testコマンドをトリガーとして、ユニットテストを自動生成（※本記事の検証２）\n\n\n検証\n\n検証に用いるAWS本家のソースコード\nJava検証用にServerless Java container、Python検証用にaws-cliをピックアップしました。\n\n\n\n\n\n\n\n検証方法\n\n該当コードをcloneします\n自動生成する予定のファイルを全部削除します\n\n検証1：README、フォルダ内に存在するドキュメント（例：docフォルダ配下すべて）\n検証2：フォルダ内に存在するテスト（例：testフォルダ配下すべて）\n\n\n\n/docコマンド or /testコマンドを実行します\n\n\n/docコマンドはコマンドを叩いたあとにREADMEを自動生成したいリポジトリを選択します\n\n/testコマンドはユニットテストを自動作成したいファイルをあらかじめアクティブ状態にしてからコマンドを叩く必要があります\n\n\n\n\n検証1：/docコマンドをトリガーとして、ドキュメントを自動生成\n\nServerless Java containerの検証結果\nServerless Java containerの実行結果はこちらです。公式のREADMEとは異なる全く異なるアウトプットであることから、「Amazon Q Developerは過学習していない（個別最適化されないように、大量のデータを学習している）」ということがわかります。\n\n中身を詳しく見ていきます。まずREADMEの目次構成は下記のようになっていました。READMEの構成として、存在すると便利な項目が綺麗に並んでおり、READMEとしての有用性が高くなっております。\n\nREADME.md の目次構成\nAWS Serverless Java Container（タイトル）\n├　Repository Structure（リポジトリ内のモジュール構成）\n├　Usage Instructions（使い方）\n│├　Installation（インストール方法）\n│├　Getting Started（インストール後の使い方）\n│├　Configuration（使う際の設定について）\n│├　Common Use Cases（主なユースケース）\n│├　Testing（テスト実行方法）\n│└　Troubleshooting（トラブルシューティング）\n├　Data Flow（データの流れ）\n├　Deployment（デプロイ方法）\n└　Infrastructure（インフラ構成）\n\n\nそれぞれの項目も、コマンドベースで丁寧に記載がされていました。また、内容もおおむね「一般的に正しいことが多い」回答となっておりました。\n例えば、トラブルシューティングの章は一般的な対応方法が記載されています。インストールの章も同じくです。\nなお、インストールバージョンに関しては、「Prerequisites」で指定されているバージョンよりも古いバージョン（例：Java17）も本OSSは利用可能と思われます。と言いますのも、本OSSはgithubのワークフロー設定（.github/workflows/continuous-integration-workflow.yml）にてJava17を指定しています。\nただ最新LTSであるJava21を推奨しているのは個人的には悪くないと思います。アシスタントする生成AI側で明確に推奨バージョンを判別できない場合、一般的には新しいLTSを使う方が推奨されるため、回答として「明確な」間違いとなる可能性が低いためです。\n\nREADME.md（一部抜粋：Installation）\n### Installation\n\nPrerequisites:\n- Java 21 or later\n- Maven 3.6.3 or later\n- AWS CLI configured with appropriate credentials\n\nTo install the AWS Serverless Java Container, clone the repository and build the project:\n\n---\ngit clone https://github.com/aws/serverless-java-container.git\ncd serverless-java-container\nmvn clean install\n---\n\n\n\nREADME.md（一部抜粋：Troubleshooting）\n### Troubleshooting\n\nCommon issues and solutions:\n\n1. ClassNotFoundException:\n   - Ensure all dependencies are correctly specified in your `pom.xml` file.\n   - Check that the `Handler` property in your `template.yml` file points to the correct class.\n\n2. API Gateway errors:\n   - Verify that your API routes are correctly defined in your application code.\n   - Check the CloudWatch logs for your Lambda function for any error messages.\n\n3. Performance issues:\n   - Consider using the `async` initialization option for faster cold starts.\n   - Optimize your application code and reduce the number of dependencies.\n\n\n\naws-cliの検証結果\nもう一つの検証対象であるaws-cliも見ていきます。READMEの目次構成は下記の通りです。\nこの目次は、Serverless Java containerのREADME自動生成の結果と完全一致はしていないものの、かなり似ております。このことから、裏側で動いている生成AI側である程度READMEの目次フォーマットを決めていることが推測できます。\n\nREADME.md の目次構成\nAWS Command Line Interface (CLI)（タイトル）\n├　Repository Structure（リポジトリ内のフォルダ構成、主要なファイル）\n├　Usage Instructions（使い方）\n│├　Installation（インストール方法）\n│├　Configuration（使う際の設定について）\n│├　Basic Usage（インストール後の基本的な使い方）\n│└　Getting Help（使い方のヘルプコマンド）\n├　Data Flow（データの流れ）\n├　Deployment（デプロイされている形式）\n├　Infrastructure（インフラ構成）\n├　Testing & Quality（テスト方法）\n├　Troubleshooting（トラブルシューティング）\n└　Performance Optimization（パフォーマンスの最適化）\n\n\n記載内容もおおむね正しいです。Repository Structureは検証のためにdocフォルダを削除しているためそれが記載されていないのは想定通りです。ドキュメント以外のフォルダは主要なものを問題なくピックアップできております。（awscliフォルダ配下にtopicsフォルダがあることを紹介できておりませんが、これは後述する「READMEの修正」で修正可能な範囲です。）\n\nREADME.md（一部抜粋：Repository Structure）\n## Repository Structure\n\nThe repository is organized as follows:\n\n- `aws-cli/`: Main directory containing the AWS CLI source code\n  - `awscli/`: Core AWS CLI implementation\n    - `customizations/`: Custom commands and behaviors for specific AWS services\n    - `data/`: Configuration data files\n    - `examples/`: Example files and templates\n  - `bin/`: Executable scripts\n  - `scripts/`: Utility scripts for development and testing\n  - `tests/`: Test suite for the AWS CLI\n\nKey Files:\n- `aws-cli/awscli/__main__.py`: Entry point for the AWS CLI\n- `aws-cli/awscli/clidriver.py`: Main driver for the CLI functionality\n- `aws-cli/setup.py`: Setup script for installing the AWS CLI\n\n\nまた、InstallationにおいてPythonのバージョンが3.8以上である必要があることは、setup.pyの記載とも一致します。\n\n\nREADME.md（一部抜粋：Installation）\n### Installation\n\n1. Ensure you have Python 3.8 or later installed.\n2. Install the AWS CLI using pip:\n\n---\npip install awscli\n---\n\n\n実際のところは、aws-cliのインストール方法は多岐にわたります。これらの情報も加味するには、別途手動で追加することになりそうです。\nなお、ここまで初回生成のREADMEを見ていきましたが、このREADMEはプロンプト指示をだすことによる修正が可能です。\n例えば、セクションの追加や削除、特定の文章自体の修正が可能です。この際、変更したいセクションや追加削除したいコンテンツ、文章の修正方針は明確に記述する必要があります。また、参照する必要があるものは、参照先がコードである必要があります。\nまた、READMEをより良いものとするためにAWS公式からベストプラクティスが提供されています。\nhttps://docs.aws.amazon.com/amazonq/latest/qdeveloper-ug/doc-generation-best-practices.html\n\n検証2：/testコマンドをトリガーとして、ユニットテストを自動生成\n/testコマンドを実行すると下記のような画面を見ることができます。なお、2024/12現在はJavaとPythonのみが対応となっております。ここでは文量の都合でaws-cliの検証結果のみ紹介します。\n\n\naws-cliの検証結果\n下記ファイルの単体テストを行いました。\nhttps://github.com/aws/aws-cli/blob/develop/awscli/customizations/s3/fileinfo.py\n該当ファイルには、下記4つのメソッドがあります。\n\n__init__(self, src, dest, compare_key, size, last_update, src_type, dest_type, operation_name, client, parameters, source_client, is_stream, associated_response_data)\nis_glacier_compatible(self)\n_is_glacier_object(self, response_data)\n_is_restored(self, response_data)\n\n生成されたテストケース一覧は下記の通りです。対象メソッド1つ1つに対して、正常ケースだけでなく異常ケースもしっかり検討されており、パターンも多く揃っております。（※番号1と3でまったく同じで何も記載のないテストが生成されていますが、この程度の余分なテストは削除する手間もたいしてないので、問題ないかと思っております。）\n\n\n\n＃\nテストメソッド\nテストの説明\nテスト対象メソッド\n\n\n\n\n1\ntest__is_glacier_object_1\n既存のテスト（変更なし）\n_is_glacier_object\n\n\n2\ntest__is_glacier_object_2\n非Glacierオブジェクトの場合にFalseを返すことをテスト\n_is_glacier_object\n\n\n3\ntest__is_glacier_object_3\n既存のテスト（変更なし）\n_is_glacier_object\n\n\n4\ntest__is_restored_with_case_sensitive_restore_value\n大文字小文字を区別するRestore値でのテスト\n_is_restored\n\n\n5\ntest__is_restored_with_empty_input\n空の入力での_is_restoredメソッドのテスト\n_is_restored\n\n\n6\ntest__is_restored_with_empty_restore_value\n空のRestore値での_is_restoredメソッドのテスト\n_is_restored\n\n\n7\ntest__is_restored_with_incorrect_type\n不正な入力タイプでの_is_restoredメソッドのテスト\n_is_restored\n\n\n8\ntest__is_restored_with_invalid_restore_value\n無効なRestore値での_is_restoredメソッドのテスト\n_is_restored\n\n\n9\ntest__is_restored_with_missing_restore_key\nRestoreキーが欠落している場合の_is_restoredメソッドのテスト\n_is_restored\n\n\n10\ntest__is_restored_with_none_input\nNone入力での_is_restoredメソッドのテスト\n_is_restored\n\n\n11\ntest__is_restored_with_ongoing_request\n進行中のリクエストでの_is_restoredメソッドのテスト\n_is_restored\n\n\n12\ntest__is_restored_with_partial_restore_value\n部分的なRestore値での_is_restoredメソッドのテスト\n_is_restored\n\n\n13\ntest_init_with_all_parameters\nすべてのパラメータを指定してFileInfoを初期化するテスト\n__init__\n\n\n14\ntest_init_with_default_parameters\nデフォルトパラメータでのFileInfo初期化テスト\n__init__\n\n\n15\ntest_init_with_empty_src\n空のsrcパラメータでの初期化テスト\n__init__\n\n\n16\ntest_init_with_invalid_associated_response_data\n無効なassociated_response_dataでの初期化テスト\n__init__\n\n\n17\ntest_init_with_invalid_dest_type\n無効なdest_typeパラメータでの初期化テスト\n__init__\n\n\n18\ntest_init_with_invalid_is_stream\n無効なis_streamパラメータでの初期化テスト\n__init__\n\n\n19\ntest_init_with_invalid_last_update\n無効なlast_updateパラメータでの初期化テスト\n__init__\n\n\n20\ntest_init_with_invalid_operation_name\n無効なoperation_nameパラメータでの初期化テスト\n__init__\n\n\n21\ntest_init_with_invalid_parameters_type\n無効なparameters型での初期化テスト\n__init__\n\n\n22\ntest_init_with_invalid_src_type\n無効なsrc_typeパラメータでの初期化テスト\n__init__\n\n\n23\ntest_init_with_negative_size\n負のsizeパラメータでの初期化テスト\n__init__\n\n\n24\ntest_init_with_parameters\nパラメータを指定してFileInfoを初期化するテスト\n__init__\n\n\n25\ntest_is_glacier_compatible_1\nGlacierオブジェクトのダウンロード操作の互換性テスト\nis_glacier_compatible\n\n\n26\ntest_is_glacier_compatible_3\nGlacierオブジェクトの削除操作の互換性テスト\nis_glacier_compatible\n\n\n27\ntest_is_glacier_compatible_deep_archive_object\nDeep Archiveオブジェクトの互換性テスト\nis_glacier_compatible\n\n\n28\ntest_is_glacier_compatible_glacier_object_copy\nGlacierオブジェクトのコピー操作の互換性テスト\nis_glacier_compatible\n\n\n29\ntest_is_glacier_compatible_glacier_object_download\nGlacierオブジェクトのダウンロード操作の互換性テスト\nis_glacier_compatible\n\n\n30\ntest_is_glacier_compatible_glacier_object_move_local_source\nローカルソースのGlacierオブジェクトの移動操作の互換性テスト\nis_glacier_compatible\n\n\n31\ntest_is_glacier_compatible_glacier_object_move_s3_source\nS3ソースのGlacierオブジェクトの移動操作の互換性テスト\nis_glacier_compatible\n\n\n32\ntest_is_glacier_compatible_glacier_upload\nGlacierオブジェクトのアップロード操作の互換性テスト\nis_glacier_compatible\n\n\n33\ntest_is_glacier_compatible_invalid_storage_class\n無効なストレージクラスでの互換性テスト\nis_glacier_compatible\n\n\n34\ntest_is_glacier_compatible_move_from_s3_glacier\nS3 Glacierからの移動操作の互換性テスト\nis_glacier_compatible\n\n\n35\ntest_is_glacier_compatible_no_associated_response_data\n関連レスポンスデータがない場合の互換性テスト\nis_glacier_compatible\n\n\n36\ntest_is_glacier_compatible_non_glacier_object\n非Glacierオブジェクトの互換性テスト\nis_glacier_compatible\n\n\n37\ntest_is_glacier_compatible_non_glacier_object_2\n別の非Glacierオブジェクトの互換性テスト\nis_glacier_compatible\n\n\n38\ntest_is_glacier_compatible_restored_glacier_object\n復元されたGlacierオブジェクトの互換性テスト\nis_glacier_compatible\n\n\n39\ntest_is_glacier_object_case_sensitivity\nストレージクラスの大文字小文字の区別テスト\n_is_glacier_object\n\n\n40\ntest_is_glacier_object_copy_operation\nGlacierオブジェクトのコピー操作のテスト\n_is_glacier_object\n\n\n41\ntest_is_glacier_object_deep_archive\nDeep Archiveストレージクラスの判定テスト\n_is_glacier_object\n\n\n42\ntest_is_glacier_object_empty_input\n空の入力での_is_glacier_objectメソッドのテスト\n_is_glacier_object\n\n\n43\ntest_is_glacier_object_incorrect_type\n不正な入力タイプでの_is_glacier_objectメソッドのテスト\n_is_glacier_object\n\n\n44\ntest_is_glacier_object_invalid_storage_class\n無効なストレージクラスでの_is_glacier_objectメソッドのテスト\n_is_glacier_object\n\n\n45\ntest_is_glacier_object_missing_storage_class\nストレージクラスが欠落している場合の_is_glacier_objectメソッドのテスト\n_is_glacier_object\n\n\n46\ntest_is_glacier_object_restored_glacier\n復元されたGlacierオブジェクトの_is_glacier_objectメソッドのテスト\n_is_glacier_object\n\n\n47\ntest_is_glacier_object_returns_false_for_empty_response_data\n空のレスポンスデータでの_is_glacier_objectメソッドのテスト\n_is_glacier_object\n\n\n48\ntest_is_glacier_object_returns_false_for_non_glacier_storage_class\n非Glacierストレージクラスでの_is_glacier_objectメソッドのテスト\n_is_glacier_object\n\n\n49\ntest_is_glacier_object_returns_false_for_none_response_data\nNoneレスポンスデータでの_is_glacier_objectメソッドのテスト\n_is_glacier_object\n\n\n50\ntest_is_glacier_object_returns_false_for_restored_glacier_object\n復元されたGlacierオブジェクトでの_is_glacier_objectメソッドのテスト\n_is_glacier_object\n\n\n51\ntest_is_glacier_object_returns_true_for_deep_archive_storage_class\nDeep Archiveストレージクラスでの_is_glacier_objectメソッドのテスト\n_is_glacier_object\n\n\n52\ntest_is_glacier_object_returns_true_for_glacier_storage_class\nGlacierストレージクラスでの_is_glacier_objectメソッドのテスト\n_is_glacier_object\n\n\n53\ntest_is_glacier_object_with_no_response_data\nレスポンスデータがない場合の_is_glacier_objectメソッドのテスト\n_is_glacier_object\n\n\n54\ntest_is_restored_when_object_is_not_restored\nオブジェクトが復元されていない場合の_is_restoredメソッドのテスト\n_is_restored\n\n\n55\ntest_is_restored_when_object_is_restored\nオブジェクトが復元された場合の_is_restoredメソッドのテスト\n_is_restored\n\n\n56\ntest_is_restored_when_restore_info_is_missing\n復元情報が欠落している場合の_is_restoredメソッドのテスト\n_is_restored\n\n\n\nテストメソッドを一部抜粋します。こちらの中身のロジックも問題なさそうです。\n\ntest_fileinfo.py（一部抜粋：6 空のRestore値での_is_restoredメソッドのテスト）\n    def test__is_restored_with_empty_restore_value(self):\n        \"\"\"\n        Test _is_restored method with empty Restore value\n        \"\"\"\n        file_info = FileInfo(src='test')\n        response_data = {'Restore': ''}\n        assert not file_info._is_restored(response_data)\n\n\n\ntest_fileinfo.py（一部抜粋：51 Deep Archiveストレージクラスでの_is_glacier_objectメソッドのテスト）\n    def test_is_glacier_object_returns_true_for_deep_archive_storage_class(self):\n        \"\"\"\n        Test that _is_glacier_object returns True for a DEEP_ARCHIVE storage class\n        that is not restored.\n        \"\"\"\n        file_info = FileInfo(src='dummy_src')\n        response_data = {\n            'StorageClass': 'DEEP_ARCHIVE',\n            'Restore': 'ongoing-request=\"true\"'\n        }\n        \n        result = file_info._is_glacier_object(response_data)\n        \n        assert result == True\n\n\nなお、本家のtest_fileinfo.pyファイルは下記の通りです。本家のユニットテストコードはより見やすいですね。とはいえ自動生成も健闘しているとは思うので、さらなる発展を期待します。\nhttps://github.com/aws/aws-cli/blob/develop/tests/unit/customizations/s3/test_fileinfo.py\n\nさいごに\n予想よりもドキュメント自動作成、ユニットテスト自動生成のクオリティが高かったため、活用できる箇所にはぜひ活用していきたいなと思いました。\nまた、ドキュメント自動生成にはサービスクォータがありますのでご注意ください！\n\n\n（参考）サービスクォータ\n\n既存のREADMEの最大サイズ：15KB\nREADMEを作成するプロジェクトに格納されているコードサイズ：200MB（非圧縮の場合）、50MB（圧縮の場合）\nタスクごとのドキュメント生成数：3\n\n\n\n  こちらはNRI OpenStandia Advent Calendar 2024の10日目の記事です。\nAWS re:Invent 2024にて、Amazon Q Developerのアップデートとして「コードに基づいたドキュメント自動生成」機能と「コードに基づいたユニットテスト自動生成」機能が発表されました。 \n\n \n\n Amazon Q Developerは、AWS社のコードやドキュメントをもとに学習が行われています。つまり、「自動生成されるドキュメント」と「自動生成されるユニットテスト」はAWS本家が手動作成しているドキュメントやユニットテストと同じようなクオリティになるのではないでしょうか。 そこで、今回はAWS社から出しているOSSを題材として、どのようなドキュメントやユニットテストが自動生成されていくかを見ていこうと思います。  Amazon Q Developerは運用開発者がVSCodeやIntelliJ等のコードエディタを用いてコーディングする際に、生成AIによるアシストをしてくれるツールです。 アシスト例はこちらです。   Java検証用にServerless Java container、Python検証用にaws-cliをピックアップしました。 \n\n \n\n    Serverless Java containerの実行結果はこちらです。公式のREADMEとは異なる全く異なるアウトプットであることから、「Amazon Q Developerは過学習していない（個別最適化されないように、大量のデータを学習している）」ということがわかります。  中身を詳しく見ていきます。まずREADMEの目次構成は下記のようになっていました。READMEの構成として、存在すると便利な項目が綺麗に並んでおり、READMEとしての有用性が高くなっております。 \nREADME.md の目次構成\nAWS Serverless Java Container（タイトル）\n├　Repository Structure（リポジトリ内のモジュール構成）\n├　Usage Instructions（使い方）\n│├　Installation（インストール方法）\n│├　Getting Started（インストール後の使い方）\n│├　Configuration（使う際の設定について）\n│├　Common Use Cases（主なユースケース）\n│├　Testing（テスト実行方法）\n│└　Troubleshooting（トラブルシューティング）\n├　Data Flow（データの流れ）\n├　Deployment（デプロイ方法）\n└　Infrastructure（インフラ構成）\n\n README.md の目次構成 README.md の目次構成 AWS Serverless Java Container（タイトル）\n├　Repository Structure（リポジトリ内のモジュール構成）\n├　Usage Instructions（使い方）\n│├　Installation（インストール方法）\n│├　Getting Started（インストール後の使い方）\n│├　Configuration（使う際の設定について）\n│├　Common Use Cases（主なユースケース）\n│├　Testing（テスト実行方法）\n│└　Troubleshooting（トラブルシューティング）\n├　Data Flow（データの流れ）\n├　Deployment（デプロイ方法）\n└　Infrastructure（インフラ構成）\n それぞれの項目も、コマンドベースで丁寧に記載がされていました。また、内容もおおむね「一般的に正しいことが多い」回答となっておりました。 例えば、トラブルシューティングの章は一般的な対応方法が記載されています。インストールの章も同じくです。\nなお、インストールバージョンに関しては、「Prerequisites」で指定されているバージョンよりも古いバージョン（例：Java17）も本OSSは利用可能と思われます。と言いますのも、本OSSはgithubのワークフロー設定（.github/workflows/continuous-integration-workflow.yml）にてJava17を指定しています。 ただ最新LTSであるJava21を推奨しているのは個人的には悪くないと思います。アシスタントする生成AI側で明確に推奨バージョンを判別できない場合、一般的には新しいLTSを使う方が推奨されるため、回答として「明確な」間違いとなる可能性が低いためです。 \nREADME.md（一部抜粋：Installation）\n### Installation\n\nPrerequisites:\n- Java 21 or later\n- Maven 3.6.3 or later\n- AWS CLI configured with appropriate credentials\n\nTo install the AWS Serverless Java Container, clone the repository and build the project:\n\n---\ngit clone https://github.com/aws/serverless-java-container.git\ncd serverless-java-container\nmvn clean install\n---\n\n README.md（一部抜粋：Installation） README.md（一部抜粋：Installation） ### Installation\n\nPrerequisites:\n- Java 21 or later\n- Maven 3.6.3 or later\n- AWS CLI configured with appropriate credentials\n\nTo install the AWS Serverless Java Container, clone the repository and build the project:\n\n---\ngit clone https://github.com/aws/serverless-java-container.git\ncd serverless-java-container\nmvn clean install\n---\n \nREADME.md（一部抜粋：Troubleshooting）\n### Troubleshooting\n\nCommon issues and solutions:\n\n1. ClassNotFoundException:\n   - Ensure all dependencies are correctly specified in your `pom.xml` file.\n   - Check that the `Handler` property in your `template.yml` file points to the correct class.\n\n2. API Gateway errors:\n   - Verify that your API routes are correctly defined in your application code.\n   - Check the CloudWatch logs for your Lambda function for any error messages.\n\n3. Performance issues:\n   - Consider using the `async` initialization option for faster cold starts.\n   - Optimize your application code and reduce the number of dependencies.\n\n README.md（一部抜粋：Troubleshooting） README.md（一部抜粋：Troubleshooting） ### Troubleshooting\n\nCommon issues and solutions:\n\n1. ClassNotFoundException:\n   - Ensure all dependencies are correctly specified in your `pom.xml` file.\n   - Check that the `Handler` property in your `template.yml` file points to the correct class.\n\n2. API Gateway errors:\n   - Verify that your API routes are correctly defined in your application code.\n   - Check the CloudWatch logs for your Lambda function for any error messages.\n\n3. Performance issues:\n   - Consider using the `async` initialization option for faster cold starts.\n   - Optimize your application code and reduce the number of dependencies.\n  もう一つの検証対象であるaws-cliも見ていきます。READMEの目次構成は下記の通りです。 この目次は、Serverless Java containerのREADME自動生成の結果と完全一致はしていないものの、かなり似ております。このことから、裏側で動いている生成AI側である程度READMEの目次フォーマットを決めていることが推測できます。 \nREADME.md の目次構成\nAWS Command Line Interface (CLI)（タイトル）\n├　Repository Structure（リポジトリ内のフォルダ構成、主要なファイル）\n├　Usage Instructions（使い方）\n│├　Installation（インストール方法）\n│├　Configuration（使う際の設定について）\n│├　Basic Usage（インストール後の基本的な使い方）\n│└　Getting Help（使い方のヘルプコマンド）\n├　Data Flow（データの流れ）\n├　Deployment（デプロイされている形式）\n├　Infrastructure（インフラ構成）\n├　Testing & Quality（テスト方法）\n├　Troubleshooting（トラブルシューティング）\n└　Performance Optimization（パフォーマンスの最適化）\n\n README.md の目次構成 README.md の目次構成 AWS Command Line Interface (CLI)（タイトル）\n├　Repository Structure（リポジトリ内のフォルダ構成、主要なファイル）\n├　Usage Instructions（使い方）\n│├　Installation（インストール方法）\n│├　Configuration（使う際の設定について）\n│├　Basic Usage（インストール後の基本的な使い方）\n│└　Getting Help（使い方のヘルプコマンド）\n├　Data Flow（データの流れ）\n├　Deployment（デプロイされている形式）\n├　Infrastructure（インフラ構成）\n├　Testing & Quality（テスト方法）\n├　Troubleshooting（トラブルシューティング）\n└　Performance Optimization（パフォーマンスの最適化）\n 記載内容もおおむね正しいです。Repository Structureは検証のためにdocフォルダを削除しているためそれが記載されていないのは想定通りです。ドキュメント以外のフォルダは主要なものを問題なくピックアップできております。（awscliフォルダ配下にtopicsフォルダがあることを紹介できておりませんが、これは後述する「READMEの修正」で修正可能な範囲です。） \nREADME.md（一部抜粋：Repository Structure）\n## Repository Structure\n\nThe repository is organized as follows:\n\n- `aws-cli/`: Main directory containing the AWS CLI source code\n  - `awscli/`: Core AWS CLI implementation\n    - `customizations/`: Custom commands and behaviors for specific AWS services\n    - `data/`: Configuration data files\n    - `examples/`: Example files and templates\n  - `bin/`: Executable scripts\n  - `scripts/`: Utility scripts for development and testing\n  - `tests/`: Test suite for the AWS CLI\n\nKey Files:\n- `aws-cli/awscli/__main__.py`: Entry point for the AWS CLI\n- `aws-cli/awscli/clidriver.py`: Main driver for the CLI functionality\n- `aws-cli/setup.py`: Setup script for installing the AWS CLI\n\n README.md（一部抜粋：Repository Structure） README.md（一部抜粋：Repository Structure） ## Repository Structure\n\nThe repository is organized as follows:\n\n- `aws-cli/`: Main directory containing the AWS CLI source code\n  - `awscli/`: Core AWS CLI implementation\n    - `customizations/`: Custom commands and behaviors for specific AWS services\n    - `data/`: Configuration data files\n    - `examples/`: Example files and templates\n  - `bin/`: Executable scripts\n  - `scripts/`: Utility scripts for development and testing\n  - `tests/`: Test suite for the AWS CLI\n\nKey Files:\n- `aws-cli/awscli/__main__.py`: Entry point for the AWS CLI\n- `aws-cli/awscli/clidriver.py`: Main driver for the CLI functionality\n- `aws-cli/setup.py`: Setup script for installing the AWS CLI\n また、InstallationにおいてPythonのバージョンが3.8以上である必要があることは、setup.pyの記載とも一致します。  \nREADME.md（一部抜粋：Installation）\n### Installation\n\n1. Ensure you have Python 3.8 or later installed.\n2. Install the AWS CLI using pip:\n\n---\npip install awscli\n---\n\n README.md（一部抜粋：Installation） README.md（一部抜粋：Installation） ### Installation\n\n1. Ensure you have Python 3.8 or later installed.\n2. Install the AWS CLI using pip:\n\n---\npip install awscli\n---\n 実際のところは、aws-cliのインストール方法は多岐にわたります。これらの情報も加味するには、別途手動で追加することになりそうです。 なお、ここまで初回生成のREADMEを見ていきましたが、このREADMEはプロンプト指示をだすことによる修正が可能です。\n例えば、セクションの追加や削除、特定の文章自体の修正が可能です。この際、変更したいセクションや追加削除したいコンテンツ、文章の修正方針は明確に記述する必要があります。また、参照する必要があるものは、参照先がコードである必要があります。 また、READMEをより良いものとするためにAWS公式からベストプラクティスが提供されています。\nhttps://docs.aws.amazon.com/amazonq/latest/qdeveloper-ug/doc-generation-best-practices.html  /testコマンドを実行すると下記のような画面を見ることができます。なお、2024/12現在はJavaとPythonのみが対応となっております。ここでは文量の都合でaws-cliの検証結果のみ紹介します。   下記ファイルの単体テストを行いました。\nhttps://github.com/aws/aws-cli/blob/develop/awscli/customizations/s3/fileinfo.py 該当ファイルには、下記4つのメソッドがあります。 生成されたテストケース一覧は下記の通りです。対象メソッド1つ1つに対して、正常ケースだけでなく異常ケースもしっかり検討されており、パターンも多く揃っております。（※番号1と3でまったく同じで何も記載のないテストが生成されていますが、この程度の余分なテストは削除する手間もたいしてないので、問題ないかと思っております。） テストメソッドを一部抜粋します。こちらの中身のロジックも問題なさそうです。 \ntest_fileinfo.py（一部抜粋：6 空のRestore値での_is_restoredメソッドのテスト）\n    def test__is_restored_with_empty_restore_value(self):\n        \"\"\"\n        Test _is_restored method with empty Restore value\n        \"\"\"\n        file_info = FileInfo(src='test')\n        response_data = {'Restore': ''}\n        assert not file_info._is_restored(response_data)\n\n test_fileinfo.py（一部抜粋：6 空のRestore値での_is_restoredメソッドのテスト） test_fileinfo.py（一部抜粋：6 空のRestore値での_is_restoredメソッドのテスト）     def test__is_restored_with_empty_restore_value(self):\n        \"\"\"\n        Test _is_restored method with empty Restore value\n        \"\"\"\n        file_info = FileInfo(src='test')\n        response_data = {'Restore': ''}\n        assert not file_info._is_restored(response_data)\n \ntest_fileinfo.py（一部抜粋：51 Deep Archiveストレージクラスでの_is_glacier_objectメソッドのテスト）\n    def test_is_glacier_object_returns_true_for_deep_archive_storage_class(self):\n        \"\"\"\n        Test that _is_glacier_object returns True for a DEEP_ARCHIVE storage class\n        that is not restored.\n        \"\"\"\n        file_info = FileInfo(src='dummy_src')\n        response_data = {\n            'StorageClass': 'DEEP_ARCHIVE',\n            'Restore': 'ongoing-request=\"true\"'\n        }\n        \n        result = file_info._is_glacier_object(response_data)\n        \n        assert result == True\n\n test_fileinfo.py（一部抜粋：51 Deep Archiveストレージクラスでの_is_glacier_objectメソッドのテスト） test_fileinfo.py（一部抜粋：51 Deep Archiveストレージクラスでの_is_glacier_objectメソッドのテスト）     def test_is_glacier_object_returns_true_for_deep_archive_storage_class(self):\n        \"\"\"\n        Test that _is_glacier_object returns True for a DEEP_ARCHIVE storage class\n        that is not restored.\n        \"\"\"\n        file_info = FileInfo(src='dummy_src')\n        response_data = {\n            'StorageClass': 'DEEP_ARCHIVE',\n            'Restore': 'ongoing-request=\"true\"'\n        }\n        \n        result = file_info._is_glacier_object(response_data)\n        \n        assert result == True\n なお、本家のtest_fileinfo.pyファイルは下記の通りです。本家のユニットテストコードはより見やすいですね。とはいえ自動生成も健闘しているとは思うので、さらなる発展を期待します。\nhttps://github.com/aws/aws-cli/blob/develop/tests/unit/customizations/s3/test_fileinfo.py  予想よりもドキュメント自動作成、ユニットテスト自動生成のクオリティが高かったため、活用できる箇所にはぜひ活用していきたいなと思いました。 また、ドキュメント自動生成にはサービスクォータがありますのでご注意ください！ \n\n（参考）サービスクォータ\n\n既存のREADMEの最大サイズ：15KB\nREADMEを作成するプロジェクトに格納されているコードサイズ：200MB（非圧縮の場合）、50MB（圧縮の場合）\nタスクごとのドキュメント生成数：3\n\n\n  \n（参考）サービスクォータ\n\n既存のREADMEの最大サイズ：15KB\nREADMEを作成するプロジェクトに格納されているコードサイズ：200MB（非圧縮の場合）、50MB（圧縮の場合）\nタスクごとのドキュメント生成数：3\n\n （参考）サービスクォータ 21Go to list of users who liked4comment0Go to list of comments 21Go to list of users who liked4comment0Go to list of comments 21Go to list of users who liked  21Go to list of users who liked 21Go to list of users who liked Go to list of users who liked 4 4 comment0Go to list of comments comment Go to list of comments  Register as a new user and use Qiita more convenientlyYou get articles that match your needsYou can efficiently read back useful informationYou can use dark themeWhat you can do with signing upSign upLogin Register as a new user and use Qiita more conveniently Sign upLogin"
    }
]